actions:
  apply_patch_locally: false
  open_pr: false
  push_gh_repo_url: ''
  skip_if_commits_reference_issue: true
agent:
  config:
    _commands:
    - arguments:
        line_number:
          description: the line number to move the window to (if not provided, the
            window will start at the top of the file)
          required: false
          type: integer
        path:
          description: the path to the file to open
          required: true
          type: string
      code: 'open() {    if [ -z "$1" ]    then        echo "Usage: open <file>"        return    fi    #
        Check if the second argument is provided    if [ -n "$2" ]; then        #
        Check if the provided argument is a valid number        if ! [[ $2 =~ ^[0-9]+$
        ]]; then            echo "Usage: open <file> [<line_number>]"            echo
        "Error: <line_number> must be a number"            return  # Exit if the line
        number is not valid        fi        local max_line=$(awk ''END {print NR}''
        $1)        if [ $2 -gt $max_line ]; then            echo "Warning: <line_number>
        ($2) is greater than the number of lines in the file ($max_line)"            echo
        "Warning: Setting <line_number> to $max_line"            local line_number=$(jq
        -n "$max_line")  # Set line number to max if greater than max        elif
        [ $2 -lt 1 ]; then            echo "Warning: <line_number> ($2) is less than
        1"            echo "Warning: Setting <line_number> to 1"            local
        line_number=$(jq -n "1")  # Set line number to 1 if less than 1        else            local
        OFFSET=$(jq -n "$WINDOW/6" | jq ''floor'')            local line_number=$(jq
        -n "[$2 + $WINDOW/2 - $OFFSET, 1] | max | floor")        fi    else        local
        line_number=$(jq -n "$WINDOW/2")  # Set default line number if not provided    fi    if
        [ -f "$1" ]; then        export CURRENT_FILE=$(realpath $1)        export
        CURRENT_LINE=$line_number        _constrain_line        _print    elif [ -d
        "$1" ]; then        echo "Error: $1 is a directory. You can only open files.
        Use cd or ls to navigate directories."    else        echo "File $1 not found"    fi}'
      docstring: opens the file at the given path in the editor. If line_number is
        provided, the window will be move to include that line
      end_name: null
      name: open
      signature: open <path> [<line_number>]
    - arguments:
        line_number:
          description: the line number to move the window to
          required: true
          type: integer
      code: 'goto() {    if [ $# -gt 1 ]; then        echo "goto allows only one line
        number at a time."        return    fi    if [ -z "$CURRENT_FILE" ]    then        echo
        "No file open. Use the open command first."        return    fi    if [ -z
        "$1" ]    then        echo "Usage: goto <line>"        return    fi    if
        ! [[ $1 =~ ^[0-9]+$ ]]    then        echo "Usage: goto <line>"        echo
        "Error: <line> must be a number"        return    fi    local max_line=$(awk
        ''END {print NR}'' $CURRENT_FILE)    if [ $1 -gt $max_line ]    then        echo
        "Error: <line> must be less than or equal to $max_line"        return    fi    local
        OFFSET=$(jq -n "$WINDOW/6" | jq ''floor'')    export CURRENT_LINE=$(jq -n
        "[$1 + $WINDOW/2 - $OFFSET, 1] | max | floor")    _constrain_line    _print}'
      docstring: moves the window to show <line_number>
      end_name: null
      name: goto
      signature: goto <line_number>
    - arguments: null
      code: scroll_down() {    if [ -z "$CURRENT_FILE" ]    then        echo "No file
        open. Use the open command first."        return    fi    export CURRENT_LINE=$(jq
        -n "$CURRENT_LINE + $WINDOW - $OVERLAP")    _constrain_line    _print}
      docstring: moves the window down {WINDOW} lines
      end_name: null
      name: scroll_down
      signature: scroll_down
    - arguments: null
      code: scroll_up() {    if [ -z "$CURRENT_FILE" ]    then        echo "No file
        open. Use the open command first."        return    fi    export CURRENT_LINE=$(jq
        -n "$CURRENT_LINE - $WINDOW + $OVERLAP")    _constrain_line    _print}
      docstring: moves the window down {WINDOW} lines
      end_name: null
      name: scroll_up
      signature: scroll_up
    - arguments:
        filename:
          description: the name of the file to create
          required: true
          type: string
      code: "create() {    if [ -z \"$1\" ]; then        echo \"Usage: create <filename>\"\
        \        return    fi    # Check if the file already exists    if [ -e \"\
        $1\" ]; then        echo \"Error: File '$1' already exists.\"\t\topen \"$1\"\
        \        return    fi    # Create the file an empty new line    printf \"\\\
        n\" > \"$1\"    # Use the existing open command to open the created file \
        \   open \"$1\"}"
      docstring: creates and opens a new file with the given name
      end_name: null
      name: create
      signature: create <filename>
    - arguments:
        dir:
          description: the directory to search in (if not provided, searches in the
            current directory)
          required: false
          type: string
        search_term:
          description: the term to search for
          required: true
          type: string
      code: 'search_dir() {    if [ $# -eq 1 ]; then        local search_term="$1"        local
        dir="./"    elif [ $# -eq 2 ]; then        local search_term="$1"        if
        [ -d "$2" ]; then            local dir="$2"        else            echo "Directory
        $2 not found"            return        fi    else        echo "Usage: search_dir
        <search_term> [<dir>]"        return    fi    dir=$(realpath "$dir")    local
        matches=$(find "$dir" -type f ! -path ''*/.*'' -exec grep -nIH -- "$search_term"
        {} + | cut -d: -f1 | sort | uniq -c)    # if no matches, return    if [ -z
        "$matches" ]; then        echo "No matches found for \"$search_term\" in $dir"        return    fi    #
        Calculate total number of matches    local num_matches=$(echo "$matches" |
        awk ''{sum+=$1} END {print sum}'')    # calculate total number of files matched    local
        num_files=$(echo "$matches" | wc -l | awk ''{$1=$1; print $0}'')    # if num_files
        is > 100, print an error    if [ $num_files -gt 100 ]; then        echo "More
        than $num_files files matched for \"$search_term\" in $dir. Please narrow
        your search."        return    fi    echo "Found $num_matches matches for
        \"$search_term\" in $dir:"    echo "$matches" | awk ''{$2=$2; gsub(/^\.+\/+/,
        "./", $2); print $2 " ("$1" matches)"}''    echo "End of matches for \"$search_term\"
        in $dir"}'
      docstring: searches for search_term in all files in dir. If dir is not provided,
        searches in the current directory
      end_name: null
      name: search_dir
      signature: search_dir <search_term> [<dir>]
    - arguments:
        file:
          description: the file to search in (if not provided, searches in the current
            open file)
          required: false
          type: string
        search_term:
          description: the term to search for
          required: true
          type: string
      code: 'search_file() {    # Check if the first argument is provided    if [
        -z "$1" ]; then        echo "Usage: search_file <search_term> [<file>]"        return    fi    #
        Check if the second argument is provided    if [ -n "$2" ]; then        #
        Check if the provided argument is a valid file        if [ -f "$2" ]; then            local
        file="$2"  # Set file if valid        else            echo "Usage: search_file
        <search_term> [<file>]"            echo "Error: File name $2 not found. Please
        provide a valid file name."            return  # Exit if the file is not valid        fi    else        #
        Check if a file is open        if [ -z "$CURRENT_FILE" ]; then            echo
        "No file open. Use the open command first."            return  # Exit if no
        file is open        fi        local file="$CURRENT_FILE"  # Set file to the
        current open file    fi    local search_term="$1"    file=$(realpath "$file")    #
        Use grep to directly get the desired formatted output    local matches=$(grep
        -nH -- "$search_term" "$file")    # Check if no matches were found    if [
        -z "$matches" ]; then        echo "No matches found for \"$search_term\" in
        $file"        return    fi    # Calculate total number of matches    local
        num_matches=$(echo "$matches" | wc -l | awk ''{$1=$1; print $0}'')    # calculate
        total number of lines matched    local num_lines=$(echo "$matches" | cut -d:
        -f1 | sort | uniq | wc -l | awk ''{$1=$1; print $0}'')    # if num_lines is
        > 100, print an error    if [ $num_lines -gt 100 ]; then        echo "More
        than $num_lines lines matched for \"$search_term\" in $file. Please narrow
        your search."        return    fi    # Print the total number of matches and
        the matches themselves    echo "Found $num_matches matches for \"$search_term\"
        in $file:"    echo "$matches" | cut -d: -f1-2 | sort -u -t: -k2,2n | while
        IFS=: read -r filename line_number; do        echo "Line $line_number:$(sed
        -n "${line_number}p" "$file")"    done    echo "End of matches for \"$search_term\"
        in $file"}'
      docstring: searches for search_term in file. If file is not provided, searches
        in the current open file
      end_name: null
      name: search_file
      signature: search_file <search_term> [<file>]
    - arguments:
        dir:
          description: the directory to search in (if not provided, searches in the
            current directory)
          required: false
          type: string
        file_name:
          description: the name of the file to search for
          required: true
          type: string
      code: 'find_file() {    if [ $# -eq 1 ]; then        local file_name="$1"        local
        dir="./"    elif [ $# -eq 2 ]; then        local file_name="$1"        if
        [ -d "$2" ]; then            local dir="$2"        else            echo "Directory
        $2 not found"            return        fi    else        echo "Usage: find_file
        <file_name> [<dir>]"        return    fi    dir=$(realpath "$dir")    local
        matches=$(find "$dir" -type f -name "$file_name")    # if no matches, return    if
        [ -z "$matches" ]; then        echo "No matches found for \"$file_name\" in
        $dir"        return    fi    # Calculate total number of matches    local
        num_matches=$(echo "$matches" | wc -l | awk ''{$1=$1; print $0}'')    echo
        "Found $num_matches matches for \"$file_name\" in $dir:"    echo "$matches"
        | awk ''{print $0}''}'
      docstring: finds all files with the given name in dir. If dir is not provided,
        searches in the current directory
      end_name: null
      name: find_file
      signature: find_file <file_name> [<dir>]
    - arguments:
        file_name:
          description: the name of file to be searched
          required: true
          type: string
        project_path:
          description: This must be the path to the root of the project.
          required: true
          type: string
      code: rover_search_file() {    python3 /root/commands/_augmented_rover_search.py
        rover_search_file "$1" "$2"}
      docstring: search for a file named <file_name> in <project_path> by using the
        project-level search engine.
      end_name: null
      name: rover_search_file
      signature: rover_search_file <project_path> <file_name>
    - arguments:
        class_name:
          description: the name of class to be searched
          required: true
          type: string
        project_path:
          description: This must be the path to the root of the project.
          required: true
          type: string
      code: rover_search_class() {    python3 /root/commands/_augmented_rover_search.py
        rover_search_class "$1" "$2"}
      docstring: search for a class named <class_name> in <project_path> by using
        the project-level search engine.
      end_name: null
      name: rover_search_class
      signature: rover_search_class <project_path> <class_name>
    - arguments:
        method_name:
          description: the name of method to be searched
          required: true
          type: string
        project_path:
          description: This must be the path to the root of the project.
          required: true
          type: string
      code: rover_search_method() {    python3 /root/commands/_augmented_rover_search.py
        rover_search_method "$1" "$2"}
      docstring: search for a method named <method_name> in <project_path> by using
        the project-level search engine.
      end_name: null
      name: rover_search_method
      signature: rover_search_method <project_path> <method_name>
    - arguments:
        code:
          description: the code to be searched
          required: true
          type: string
        project_path:
          description: This must be the path to the root of the project.
          required: true
          type: string
      code: rover_search_code() {    python3 /root/commands/_augmented_rover_search.py
        rover_search_code "$1" "$2"}
      docstring: search for a code snippet <code> in <project_path> by using the project-level
        search engine.
      end_name: null
      name: rover_search_code
      signature: rover_search_code <project_path> <code>
    - arguments:
        code:
          description: the code to be searched
          required: true
          type: string
        file_name:
          description: the name of the file in which the <code> is to be searched.
          required: true
          type: string
        project_path:
          description: This must be the path to the root of the project.
          required: true
          type: string
      code: rover_search_code_in_file() {    python3 /root/commands/_augmented_rover_search.py
        rover_search_code_in_file "$1" "$2" "$3"}
      docstring: search for a code snippet <code> in <file_name> from the directory
        <project_path> by using the project-level search engine.
      end_name: null
      name: rover_search_code_in_file
      signature: rover_search_code_in_file <project_path> <file_name> <code>
    - arguments:
        end_line:
          description: the line number to end the edit at (inclusive)
          required: true
          type: integer
        replacement_text:
          description: the text to replace the current selection with
          required: true
          type: string
        start_line:
          description: the line number to start the edit at
          required: true
          type: integer
      code: 'edit() {    if [ -z "$CURRENT_FILE" ]    then        echo ''No file open.
        Use the `open` command first.''        return    fi    local start_line="$(echo
        $1: | cut -d: -f1)"    local end_line="$(echo $1: | cut -d: -f2)"    if [
        -z "$start_line" ] || [ -z "$end_line" ]    then        echo "Usage: edit
        <start_line>:<end_line>"        return    fi    local re=''^[0-9]+$''    if
        ! [[ $start_line =~ $re ]]; then        echo "Usage: edit <start_line>:<end_line>"        echo
        "Error: start_line must be a number"        return    fi    if ! [[ $end_line
        =~ $re ]]; then        echo "Usage: edit <start_line>:<end_line>"        echo
        "Error: end_line must be a number"        return    fi    # Bash array starts
        at 0, so let''s adjust    local start_line=$((start_line - 1))    local end_line=$((end_line))    local
        line_count=0    local replacement=()    while IFS= read -r line    do        replacement+=("$line")        ((line_count++))    done    #
        Create a backup of the current file    cp "$CURRENT_FILE" "/root/$(basename
        "$CURRENT_FILE")_backup"    # Read the file line by line into an array    mapfile
        -t lines < "$CURRENT_FILE"    local new_lines=("${lines[@]:0:$start_line}"
        "${replacement[@]}" "${lines[@]:$((end_line))}")    # Write the new stuff
        directly back into the original file    printf "%s\n" "${new_lines[@]}" >|
        "$CURRENT_FILE"    # Run linter    if [[ $CURRENT_FILE == *.py ]]; then        lint_output=$(flake8
        --isolated --select=F821,F822,F831,E111,E112,E113,E999,E902 "$CURRENT_FILE"
        2>&1)    else        # do nothing        lint_output=""    fi    # if there
        is no output, then the file is good    if [ -z "$lint_output" ]; then        export
        CURRENT_LINE=$start_line        _constrain_line        _print        echo
        "File updated. Please review the changes and make sure they are correct (correct
        indentation, no duplicate lines, etc). Edit the file again if necessary."    else        echo
        "Your proposed edit has introduced new syntax error(s). Please read this error
        message carefully and then retry editing the file."        echo ""        echo
        "ERRORS:"        _split_string "$lint_output"        echo ""        # Save
        original values        original_current_line=$CURRENT_LINE        original_window=$WINDOW        #
        Update values        export CURRENT_LINE=$(( (line_count / 2) + start_line
        )) # Set to "center" of edit        export WINDOW=$((line_count + 10)) # Show
        +/- 5 lines around edit        echo "This is how your edit would have looked
        if applied"        echo "-------------------------------------------------"        _constrain_line        _print        echo
        "-------------------------------------------------"        echo ""        #
        Restoring CURRENT_FILE to original contents.        cp "/root/$(basename "$CURRENT_FILE")_backup"
        "$CURRENT_FILE"        export CURRENT_LINE=$(( ((end_line - start_line + 1)
        / 2) + start_line ))        export WINDOW=$((end_line - start_line + 10))        echo
        "This is the original code before your edit"        echo "-------------------------------------------------"        _constrain_line        _print        echo
        "-------------------------------------------------"        # Restore original
        values        export CURRENT_LINE=$original_current_line        export WINDOW=$original_window        echo
        "Your changes have NOT been applied. Please fix your edit command and try
        again."        echo "You either need to 1) Specify the correct start/end line
        arguments or 2) Correct your edit code."        echo "DO NOT re-run the same
        failed edit command. Running it again will lead to the same error."    fi    #
        Remove backup file    rm -f "/root/$(basename "$CURRENT_FILE")_backup"}'
      docstring: replaces lines <start_line> through <end_line> (inclusive) with the
        given text in the open file. The replacement text is terminated by a line
        with only end_of_edit on it. All of the <replacement text> will be entered,
        so make sure your indentation is formatted properly. Python files will be
        checked for syntax errors after the edit. If the system detects a syntax error,
        the edit will not be executed. Simply try to edit the file again, but make
        sure to read the error message and modify the edit command you issue accordingly.
        Issuing the same command a second time will just lead to the same error message
        again.
      end_name: end_of_edit
      name: edit
      signature: |-
        edit <start_line>:<end_line>
        <replacement_text>
        end_of_edit
    - arguments: null
      code: 'submit() {    cd $ROOT    # Check if the patch file exists and is non-empty    if
        [ -s "/root/test.patch" ]; then        # Apply the patch in reverse        git
        apply -R < "/root/test.patch"    fi    git add -A    git diff --cached > model.patch    echo
        "<<SUBMISSION||"    cat model.patch    echo "||SUBMISSION>>"}'
      docstring: submits your current code and terminates the session
      end_name: null
      name: submit
      signature: submit
    - arguments:
        directory:
          description: the directory to search for test files (defaults to the current
            directory)
          required: false
          type: string
      code: 'find_test_files() {    local dir=${1:-.}        if [ ! -d "$dir" ]; then        echo
        "Error: $dir is not a valid directory."        return    fi        echo "Searching
        for test files in $dir..."        # Find files ending with _test.py or in
        a tests directory    local test_files=$(find "$dir" -type f \( -name ''*_test.py''
        -o -path ''*/tests/*.py'' \))        if [ -z "$test_files" ]; then        echo
        "No test files found in $dir."    else        echo "Test files found:"        echo
        "$test_files"    fi}'
      docstring: finds and lists all test files in the current or specified directory
      end_name: null
      name: find_test_files
      signature: find_test_files [<directory>]
    - arguments: null
      code: 'warning_pytest() {    echo "Warning: Before running pytest, please make
        sure you have first identified the relevant test files (.py) for the issue.
        Run find_test_files and decide which test files are relevant. Please do not
        use keyword-based grep to choose the relevancy. Rerun the command providing
        the specific test files (.py) to execute only those tests. Please don''t run
        on specific test cases to ensure efficiency."}'
      docstring: warns the user that pytest should be run on relevant test files only
      end_name: null
      name: warning_pytest
      signature: warning_pytest
    - arguments: null
      code: 'failed_test_message() {    echo "Reminder: When analyzing failed test
        cases, you must consider the following:"    echo ""    echo "First, analyze
        the failure message and the stack trace to understand what went wrong."    echo
        "Then, formulate a plan to fix each test case (or group of test cases) that
        failed."    echo ""}'
      docstring: strategies to handle failed test cases
      end_name: null
      name: failed_test_message
      signature: failed_test_message
    - arguments: null
      code: update_plan() {    echo "The plan has been updated."}
      docstring: The plan has been updated.
      end_name: null
      name: update_plan
      signature: update_plan
    - arguments: null
      code: end_conversation() {    echo "Ending the conversation."}
      docstring: end the conversation
      end_name: null
      name: end_conversation
      signature: end_conversation
    - arguments: null
      code: 'warning_message_edit() {    echo "WARNING: You attempted to edit the
        code. As a debugger, you cannot directly edit the code. Please leave the code
        editing to the programmer, by requesting the programmer to edit the code via
        update_plan command."}'
      docstring: display a warning message
      end_name: null
      name: warning_message_edit
      signature: warning_message_edit
    - arguments: null
      code: 'request_new_test_session() {    echo "Message to Debugger/Tester: Requesting
        a new independent test session."    echo    echo "ACTION ITEMS:"    echo "[1]
        INDEPENDENTLY run ''reproduce.py'' to verify the current state of the original
        issue."    echo "[2a] EXECUTE relevant pytest unit test file without assuming
        any previous results."      echo "[2b] REVIEW ''expanded_test.py'' to ensure
        it expands test coverage beyond ''reproduce.py''."    echo "[3] EXECUTE ''expanded_test.py''
        to verify expanded test coverage and functionality."    echo "If [1], [2a],
        [2b], and [3] are all verified successfully, submit the patch by running the
        end_conversation command. Otherwise, REPORT your findings based solely on
        this new test session."    echo    echo "IMPORTANT:"    echo "- Do NOT rely
        on any previous statements about test results."    echo "- Your role is to
        independently verify and report the current state of the system."    echo
        "- If ''expanded_test.py'' does not exist or is inadequate, work with the
        Programmer to create or improve it before proceeding."}'
      docstring: request the Debugger/Tester for an independent verification of the
        current state using both the original and expanded reproduction tests
      end_name: null
      name: request_new_test_session
      signature: request_new_test_session
    - arguments: null
      code: end_conversation() {    echo "Ending the conversation."}
      docstring: end the conversation
      end_name: null
      name: end_conversation
      signature: end_conversation
    - arguments: null
      code: 'warning_message_submit_patch() {    echo "WARNING: As editor you cannot
        directly submit the patch. Please run request_submit_patch command to request
        the tester to verify the patch and submit it."}'
      docstring: display a warning message
      end_name: null
      name: warning_message_submit_patch
      signature: warning_message_submit_patch
    - arguments: null
      code: request_submit_patch() {    echo "Requesting the Debugger to verify the
        patch and submit it."}
      docstring: request the tester to verify the patch and submit it
      end_name: null
      name: request_submit_patch
      signature: request_submit_patch
    - arguments: null
      code: 'warning_message_multiple_code_blocks() {    echo "Warning: I detected
        multiple code blocks in the previous message. Please only include one code
        block in your response, so that actions can be executed one by one."    echo
        ""    echo "Correct format (sequence of single actions, each with a thought):"    echo
        ""    echo "--- First Action ---"    echo ""    echo ""    echo "\`\`\`"    echo
        "edit file.py 10:15"    echo "def validate_user_input(input_string):"    echo
        "    return input_string.strip() != ''''"    echo "end_of_edit"    echo "\`\`\`"    echo
        ""    echo "After this edit is processed, proceed with the next action in
        a new message:"    echo ""    echo "--- Second Action ---"    echo ""    echo
        ""    echo "\`\`\`"    echo "edit file.py 20:25"    echo "def main():"    echo
        "    user_input = input(''Enter your name: '')"    echo "    if validate_user_input(user_input):"    echo
        "        print(f''Hello, {user_input}!'')"    echo "    else:"    echo "        print(''Invalid
        input'')"    echo "end_of_edit"    echo "\`\`\`"    echo ""    echo "Continue
        this pattern for each subsequent action, always including one thought and
        one code block per message."}'
      docstring: Display a warning message about multiple code blocks, including examples
        of correct formatting as a simple sequence
      end_name: null
      name: warning_message_multiple_code_blocks
      signature: warning_message_multiple_code_blocks
    - arguments: null
      code: 'warning_programmer_pytest() {    echo "Warning: As a Programmer, you
        cannot directly run pytest. If you feel that the code is ready, please run
        request_new_test_session command to request the Debugger to evaluate the code
        and submit the patch, along with a summary of the changes you made and what
        you are trying to test."}'
      docstring: warns the user that pytest should be run on relevant test files only
      end_name: null
      name: warning_programmer_pytest
      signature: warning_programmer_pytest
    - arguments: null
      code: 'warning_programmer_rm() {    echo "Warning: As a Programmer, you cannot
        directly remove the reproduction script. If you feel that the code is ready,
        please run request_new_test_session command to request the Debugger to evaluate
        the code and submit the patch."}'
      docstring: please don't remove reproduction script
      end_name: null
      name: warning_programmer_rm
      signature: warning_programmer_rm
    _subroutines:
      Debugger:
        agent_args:
          config:
            _commands:
            - arguments:
                line_number:
                  description: the line number to move the window to (if not provided,
                    the window will start at the top of the file)
                  required: false
                  type: integer
                path:
                  description: the path to the file to open
                  required: true
                  type: string
              code: 'open() {    if [ -z "$1" ]    then        echo "Usage: open <file>"        return    fi    #
                Check if the second argument is provided    if [ -n "$2" ]; then        #
                Check if the provided argument is a valid number        if ! [[ $2
                =~ ^[0-9]+$ ]]; then            echo "Usage: open <file> [<line_number>]"            echo
                "Error: <line_number> must be a number"            return  # Exit
                if the line number is not valid        fi        local max_line=$(awk
                ''END {print NR}'' $1)        if [ $2 -gt $max_line ]; then            echo
                "Warning: <line_number> ($2) is greater than the number of lines in
                the file ($max_line)"            echo "Warning: Setting <line_number>
                to $max_line"            local line_number=$(jq -n "$max_line")  #
                Set line number to max if greater than max        elif [ $2 -lt 1
                ]; then            echo "Warning: <line_number> ($2) is less than
                1"            echo "Warning: Setting <line_number> to 1"            local
                line_number=$(jq -n "1")  # Set line number to 1 if less than 1        else            local
                OFFSET=$(jq -n "$WINDOW/6" | jq ''floor'')            local line_number=$(jq
                -n "[$2 + $WINDOW/2 - $OFFSET, 1] | max | floor")        fi    else        local
                line_number=$(jq -n "$WINDOW/2")  # Set default line number if not
                provided    fi    if [ -f "$1" ]; then        export CURRENT_FILE=$(realpath
                $1)        export CURRENT_LINE=$line_number        _constrain_line        _print    elif
                [ -d "$1" ]; then        echo "Error: $1 is a directory. You can only
                open files. Use cd or ls to navigate directories."    else        echo
                "File $1 not found"    fi}'
              docstring: opens the file at the given path in the editor. If line_number
                is provided, the window will be move to include that line
              end_name: null
              name: open
              signature: open <path> [<line_number>]
            - arguments:
                line_number:
                  description: the line number to move the window to
                  required: true
                  type: integer
              code: 'goto() {    if [ $# -gt 1 ]; then        echo "goto allows only
                one line number at a time."        return    fi    if [ -z "$CURRENT_FILE"
                ]    then        echo "No file open. Use the open command first."        return    fi    if
                [ -z "$1" ]    then        echo "Usage: goto <line>"        return    fi    if
                ! [[ $1 =~ ^[0-9]+$ ]]    then        echo "Usage: goto <line>"        echo
                "Error: <line> must be a number"        return    fi    local max_line=$(awk
                ''END {print NR}'' $CURRENT_FILE)    if [ $1 -gt $max_line ]    then        echo
                "Error: <line> must be less than or equal to $max_line"        return    fi    local
                OFFSET=$(jq -n "$WINDOW/6" | jq ''floor'')    export CURRENT_LINE=$(jq
                -n "[$1 + $WINDOW/2 - $OFFSET, 1] | max | floor")    _constrain_line    _print}'
              docstring: moves the window to show <line_number>
              end_name: null
              name: goto
              signature: goto <line_number>
            - arguments: null
              code: scroll_down() {    if [ -z "$CURRENT_FILE" ]    then        echo
                "No file open. Use the open command first."        return    fi    export
                CURRENT_LINE=$(jq -n "$CURRENT_LINE + $WINDOW - $OVERLAP")    _constrain_line    _print}
              docstring: moves the window down {WINDOW} lines
              end_name: null
              name: scroll_down
              signature: scroll_down
            - arguments: null
              code: scroll_up() {    if [ -z "$CURRENT_FILE" ]    then        echo
                "No file open. Use the open command first."        return    fi    export
                CURRENT_LINE=$(jq -n "$CURRENT_LINE - $WINDOW + $OVERLAP")    _constrain_line    _print}
              docstring: moves the window down {WINDOW} lines
              end_name: null
              name: scroll_up
              signature: scroll_up
            - arguments:
                filename:
                  description: the name of the file to create
                  required: true
                  type: string
              code: "create() {    if [ -z \"$1\" ]; then        echo \"Usage: create\
                \ <filename>\"        return    fi    # Check if the file already\
                \ exists    if [ -e \"$1\" ]; then        echo \"Error: File '$1'\
                \ already exists.\"\t\topen \"$1\"        return    fi    # Create\
                \ the file an empty new line    printf \"\\n\" > \"$1\"    # Use the\
                \ existing open command to open the created file    open \"$1\"}"
              docstring: creates and opens a new file with the given name
              end_name: null
              name: create
              signature: create <filename>
            - arguments:
                dir:
                  description: the directory to search in (if not provided, searches
                    in the current directory)
                  required: false
                  type: string
                search_term:
                  description: the term to search for
                  required: true
                  type: string
              code: 'search_dir() {    if [ $# -eq 1 ]; then        local search_term="$1"        local
                dir="./"    elif [ $# -eq 2 ]; then        local search_term="$1"        if
                [ -d "$2" ]; then            local dir="$2"        else            echo
                "Directory $2 not found"            return        fi    else        echo
                "Usage: search_dir <search_term> [<dir>]"        return    fi    dir=$(realpath
                "$dir")    local matches=$(find "$dir" -type f ! -path ''*/.*'' -exec
                grep -nIH -- "$search_term" {} + | cut -d: -f1 | sort | uniq -c)    #
                if no matches, return    if [ -z "$matches" ]; then        echo "No
                matches found for \"$search_term\" in $dir"        return    fi    #
                Calculate total number of matches    local num_matches=$(echo "$matches"
                | awk ''{sum+=$1} END {print sum}'')    # calculate total number of
                files matched    local num_files=$(echo "$matches" | wc -l | awk ''{$1=$1;
                print $0}'')    # if num_files is > 100, print an error    if [ $num_files
                -gt 100 ]; then        echo "More than $num_files files matched for
                \"$search_term\" in $dir. Please narrow your search."        return    fi    echo
                "Found $num_matches matches for \"$search_term\" in $dir:"    echo
                "$matches" | awk ''{$2=$2; gsub(/^\.+\/+/, "./", $2); print $2 " ("$1"
                matches)"}''    echo "End of matches for \"$search_term\" in $dir"}'
              docstring: searches for search_term in all files in dir. If dir is not
                provided, searches in the current directory
              end_name: null
              name: search_dir
              signature: search_dir <search_term> [<dir>]
            - arguments:
                file:
                  description: the file to search in (if not provided, searches in
                    the current open file)
                  required: false
                  type: string
                search_term:
                  description: the term to search for
                  required: true
                  type: string
              code: 'search_file() {    # Check if the first argument is provided    if
                [ -z "$1" ]; then        echo "Usage: search_file <search_term> [<file>]"        return    fi    #
                Check if the second argument is provided    if [ -n "$2" ]; then        #
                Check if the provided argument is a valid file        if [ -f "$2"
                ]; then            local file="$2"  # Set file if valid        else            echo
                "Usage: search_file <search_term> [<file>]"            echo "Error:
                File name $2 not found. Please provide a valid file name."            return  #
                Exit if the file is not valid        fi    else        # Check if
                a file is open        if [ -z "$CURRENT_FILE" ]; then            echo
                "No file open. Use the open command first."            return  # Exit
                if no file is open        fi        local file="$CURRENT_FILE"  #
                Set file to the current open file    fi    local search_term="$1"    file=$(realpath
                "$file")    # Use grep to directly get the desired formatted output    local
                matches=$(grep -nH -- "$search_term" "$file")    # Check if no matches
                were found    if [ -z "$matches" ]; then        echo "No matches found
                for \"$search_term\" in $file"        return    fi    # Calculate
                total number of matches    local num_matches=$(echo "$matches" | wc
                -l | awk ''{$1=$1; print $0}'')    # calculate total number of lines
                matched    local num_lines=$(echo "$matches" | cut -d: -f1 | sort
                | uniq | wc -l | awk ''{$1=$1; print $0}'')    # if num_lines is >
                100, print an error    if [ $num_lines -gt 100 ]; then        echo
                "More than $num_lines lines matched for \"$search_term\" in $file.
                Please narrow your search."        return    fi    # Print the total
                number of matches and the matches themselves    echo "Found $num_matches
                matches for \"$search_term\" in $file:"    echo "$matches" | cut -d:
                -f1-2 | sort -u -t: -k2,2n | while IFS=: read -r filename line_number;
                do        echo "Line $line_number:$(sed -n "${line_number}p" "$file")"    done    echo
                "End of matches for \"$search_term\" in $file"}'
              docstring: searches for search_term in file. If file is not provided,
                searches in the current open file
              end_name: null
              name: search_file
              signature: search_file <search_term> [<file>]
            - arguments:
                dir:
                  description: the directory to search in (if not provided, searches
                    in the current directory)
                  required: false
                  type: string
                file_name:
                  description: the name of the file to search for
                  required: true
                  type: string
              code: 'find_file() {    if [ $# -eq 1 ]; then        local file_name="$1"        local
                dir="./"    elif [ $# -eq 2 ]; then        local file_name="$1"        if
                [ -d "$2" ]; then            local dir="$2"        else            echo
                "Directory $2 not found"            return        fi    else        echo
                "Usage: find_file <file_name> [<dir>]"        return    fi    dir=$(realpath
                "$dir")    local matches=$(find "$dir" -type f -name "$file_name")    #
                if no matches, return    if [ -z "$matches" ]; then        echo "No
                matches found for \"$file_name\" in $dir"        return    fi    #
                Calculate total number of matches    local num_matches=$(echo "$matches"
                | wc -l | awk ''{$1=$1; print $0}'')    echo "Found $num_matches matches
                for \"$file_name\" in $dir:"    echo "$matches" | awk ''{print $0}''}'
              docstring: finds all files with the given name in dir. If dir is not
                provided, searches in the current directory
              end_name: null
              name: find_file
              signature: find_file <file_name> [<dir>]
            - arguments:
                file_name:
                  description: the name of file to be searched
                  required: true
                  type: string
                project_path:
                  description: This must be the path to the root of the project.
                  required: true
                  type: string
              code: rover_search_file() {    python3 /root/commands/_augmented_rover_search.py
                rover_search_file "$1" "$2"}
              docstring: search for a file named <file_name> in <project_path> by
                using the project-level search engine.
              end_name: null
              name: rover_search_file
              signature: rover_search_file <project_path> <file_name>
            - arguments:
                class_name:
                  description: the name of class to be searched
                  required: true
                  type: string
                project_path:
                  description: This must be the path to the root of the project.
                  required: true
                  type: string
              code: rover_search_class() {    python3 /root/commands/_augmented_rover_search.py
                rover_search_class "$1" "$2"}
              docstring: search for a class named <class_name> in <project_path> by
                using the project-level search engine.
              end_name: null
              name: rover_search_class
              signature: rover_search_class <project_path> <class_name>
            - arguments:
                method_name:
                  description: the name of method to be searched
                  required: true
                  type: string
                project_path:
                  description: This must be the path to the root of the project.
                  required: true
                  type: string
              code: rover_search_method() {    python3 /root/commands/_augmented_rover_search.py
                rover_search_method "$1" "$2"}
              docstring: search for a method named <method_name> in <project_path>
                by using the project-level search engine.
              end_name: null
              name: rover_search_method
              signature: rover_search_method <project_path> <method_name>
            - arguments:
                code:
                  description: the code to be searched
                  required: true
                  type: string
                project_path:
                  description: This must be the path to the root of the project.
                  required: true
                  type: string
              code: rover_search_code() {    python3 /root/commands/_augmented_rover_search.py
                rover_search_code "$1" "$2"}
              docstring: search for a code snippet <code> in <project_path> by using
                the project-level search engine.
              end_name: null
              name: rover_search_code
              signature: rover_search_code <project_path> <code>
            - arguments:
                code:
                  description: the code to be searched
                  required: true
                  type: string
                file_name:
                  description: the name of the file in which the <code> is to be searched.
                  required: true
                  type: string
                project_path:
                  description: This must be the path to the root of the project.
                  required: true
                  type: string
              code: rover_search_code_in_file() {    python3 /root/commands/_augmented_rover_search.py
                rover_search_code_in_file "$1" "$2" "$3"}
              docstring: search for a code snippet <code> in <file_name> from the
                directory <project_path> by using the project-level search engine.
              end_name: null
              name: rover_search_code_in_file
              signature: rover_search_code_in_file <project_path> <file_name> <code>
            - arguments: null
              code: update_plan() {    echo "The plan has been updated."}
              docstring: The plan has been updated.
              end_name: null
              name: update_plan
              signature: update_plan
            - arguments: null
              code: end_conversation() {    echo "Ending the conversation."}
              docstring: end the conversation
              end_name: null
              name: end_conversation
              signature: end_conversation
            - arguments: null
              code: 'warning_message_edit() {    echo "WARNING: You attempted to edit
                the code. As a debugger, you cannot directly edit the code. Please
                leave the code editing to the programmer, by requesting the programmer
                to edit the code via update_plan command."}'
              docstring: display a warning message
              end_name: null
              name: warning_message_edit
              signature: warning_message_edit
            - arguments:
                directory:
                  description: the directory to search for test files (defaults to
                    the current directory)
                  required: false
                  type: string
              code: 'find_test_files() {    local dir=${1:-.}        if [ ! -d "$dir"
                ]; then        echo "Error: $dir is not a valid directory."        return    fi        echo
                "Searching for test files in $dir..."        # Find files ending with
                _test.py or in a tests directory    local test_files=$(find "$dir"
                -type f \( -name ''*_test.py'' -o -path ''*/tests/*.py'' \))        if
                [ -z "$test_files" ]; then        echo "No test files found in $dir."    else        echo
                "Test files found:"        echo "$test_files"    fi}'
              docstring: finds and lists all test files in the current or specified
                directory
              end_name: null
              name: find_test_files
              signature: find_test_files [<directory>]
            - arguments: null
              code: 'warning_pytest() {    echo "Warning: Before running pytest, please
                make sure you have first identified the relevant test files (.py)
                for the issue. Run find_test_files and decide which test files are
                relevant. Please do not use keyword-based grep to choose the relevancy.
                Rerun the command providing the specific test files (.py) to execute
                only those tests. Please don''t run on specific test cases to ensure
                efficiency."}'
              docstring: warns the user that pytest should be run on relevant test
                files only
              end_name: null
              name: warning_pytest
              signature: warning_pytest
            - arguments: null
              code: 'failed_test_message() {    echo "Reminder: When analyzing failed
                test cases, you must consider the following:"    echo ""    echo "First,
                analyze the failure message and the stack trace to understand what
                went wrong."    echo "Then, formulate a plan to fix each test case
                (or group of test cases) that failed."    echo ""}'
              docstring: strategies to handle failed test cases
              end_name: null
              name: failed_test_message
              signature: failed_test_message
            _subroutines: {}
            blocklist:
            - vim
            - vi
            - emacs
            - nano
            - nohup
            - git
            blocklist_error_template: Interactive operation '{name}' is not supported
              by this environment
            blocklist_standalone:
            - python
            - python3
            - ipython
            - bash
            - sh
            - exit
            - /bin/bash
            - /bin/sh
            - nohup
            - vi
            - vim
            - emacs
            - nano
            command_docs: |+
              open:
                docstring: opens the file at the given path in the editor. If line_number is provided, the window will be move to include that line
                signature: open <path> [<line_number>]
                arguments:
                  - path (string) [required]: the path to the file to open
                  - line_number (integer) [optional]: the line number to move the window to (if not provided, the window will start at the top of the file)

              goto:
                docstring: moves the window to show <line_number>
                signature: goto <line_number>
                arguments:
                  - line_number (integer) [required]: the line number to move the window to

              scroll_down:
                docstring: moves the window down {WINDOW} lines
                signature: scroll_down

              scroll_up:
                docstring: moves the window down {WINDOW} lines
                signature: scroll_up

              create:
                docstring: creates and opens a new file with the given name
                signature: create <filename>
                arguments:
                  - filename (string) [required]: the name of the file to create

              search_dir:
                docstring: searches for search_term in all files in dir. If dir is not provided, searches in the current directory
                signature: search_dir <search_term> [<dir>]
                arguments:
                  - search_term (string) [required]: the term to search for
                  - dir (string) [optional]: the directory to search in (if not provided, searches in the current directory)

              search_file:
                docstring: searches for search_term in file. If file is not provided, searches in the current open file
                signature: search_file <search_term> [<file>]
                arguments:
                  - search_term (string) [required]: the term to search for
                  - file (string) [optional]: the file to search in (if not provided, searches in the current open file)

              find_file:
                docstring: finds all files with the given name in dir. If dir is not provided, searches in the current directory
                signature: find_file <file_name> [<dir>]
                arguments:
                  - file_name (string) [required]: the name of the file to search for
                  - dir (string) [optional]: the directory to search in (if not provided, searches in the current directory)

              rover_search_file:
                docstring: search for a file named <file_name> in <project_path> by using the project-level search engine.
                signature: rover_search_file <project_path> <file_name>
                arguments:
                  - project_path (string) [required]: This must be the path to the root of the project.
                  - file_name (string) [required]: the name of file to be searched

              rover_search_class:
                docstring: search for a class named <class_name> in <project_path> by using the project-level search engine.
                signature: rover_search_class <project_path> <class_name>
                arguments:
                  - project_path (string) [required]: This must be the path to the root of the project.
                  - class_name (string) [required]: the name of class to be searched

              rover_search_method:
                docstring: search for a method named <method_name> in <project_path> by using the project-level search engine.
                signature: rover_search_method <project_path> <method_name>
                arguments:
                  - project_path (string) [required]: This must be the path to the root of the project.
                  - method_name (string) [required]: the name of method to be searched

              rover_search_code:
                docstring: search for a code snippet <code> in <project_path> by using the project-level search engine.
                signature: rover_search_code <project_path> <code>
                arguments:
                  - project_path (string) [required]: This must be the path to the root of the project.
                  - code (string) [required]: the code to be searched

              rover_search_code_in_file:
                docstring: search for a code snippet <code> in <file_name> from the directory <project_path> by using the project-level search engine.
                signature: rover_search_code_in_file <project_path> <file_name> <code>
                arguments:
                  - project_path (string) [required]: This must be the path to the root of the project.
                  - file_name (string) [required]: the name of the file in which the <code> is to be searched.
                  - code (string) [required]: the code to be searched

              update_plan:
                docstring: The plan has been updated.
                signature: update_plan

              end_conversation:
                docstring: end the conversation
                signature: end_conversation

              warning_message_edit:
                docstring: display a warning message
                signature: warning_message_edit

              find_test_files:
                docstring: finds and lists all test files in the current or specified directory
                signature: find_test_files [<directory>]
                arguments:
                  - directory (string) [optional]: the directory to search for test files (defaults to the current directory)

              warning_pytest:
                docstring: warns the user that pytest should be run on relevant test files only
                signature: warning_pytest

              failed_test_message:
                docstring: strategies to handle failed test cases
                signature: failed_test_message

            command_files:
            - /home/minkim/swe/testgen/swe_proj2/config/commands/defaults.sh
            - /home/minkim/swe/testgen/swe_proj2/config/commands/search.sh
            - /home/minkim/swe/testgen/swe_proj2/config/commands/_augmented_rover_search.py
            - /home/minkim/swe/testgen/swe_proj2/config/commands/rover_search.sh
            - /home/minkim/swe/testgen/swe_proj2/config/commands/chat_debugger.sh
            - /home/minkim/swe/testgen/swe_proj2/config/commands/unit_test.sh
            demonstration_template: |
              Here is a demonstration of how to correctly accomplish this task.
              It is included to show you how to correctly use the interface.
              You do not need to follow exactly what is done in the demonstration.
              --- DEMONSTRATION ---
              {demonstration}
              --- END OF DEMONSTRATION ---
            demonstrations:
            - /home/minkim/swe/testgen/swe_proj2/trajectories/demonstrations/multi_roles/chat_debugger_v7.traj
            env_variables:
              CURRENT_FILE: ''
              CURRENT_LINE: '0'
              OVERLAP: '2'
              SEARCH_FILES: ()
              SEARCH_INDEX: '0'
              SEARCH_RESULTS: ()
              WINDOW: '100'
            format_error_template: |
              Your output was not formatted correctly. You must always include one discussion and one command as part of your response. Make sure you do not have multiple discussion/command tags.
              Please make sure your output precisely matches the following format:
              DISCUSSION
              Discuss here with yourself about what your planning and what you're going to do in this step.

              ```
              command(s) that you're going to run
              ```
            history_processor: {}
            history_processor_args:
              max_tokens: 40000
              n: 5
            instance_template: "We're currently solving the following issue within\
              \ our repository. Here's the issue text:\nISSUE:\n{issue}\n\nINSTRUCTIONS:\n\
              You are the Debugger/Tester working in collaboration with a Programmer.\
              \ Your role is to guide the improvement of the v1 patch and the creation\
              \ or enhancement of an expanded_test.py file that expands test coverage\
              \ by referring to the existing tests in the repository, while still\
              \ ensuring the functionality mentioned in the issue.\n\nBegin your terminal\
              \ session in the root directory of the repository. Use bash commands\
              \ or the special interface as needed. ENTER ONE COMMAND AT A TIME and\
              \ wait for a response before proceeding. You can run scripts (e.g.,\
              \ `python <script_name>.py`) but cannot use interactive session commands\
              \ (e.g., vim).\n\n# \U0001F50D FIXED TEST SESSION PLAN \U0001F50D\n\n\
              As the Debugger/Tester, you MUST ALWAYS follow this EXACT plan after\
              \ EACH interaction with the Programmer. NO EXCEPTIONS.\n\n## \U0001F504\
              \ REPEAT THIS SEQUENCE AFTER EVERY PROGRAMMER INTERACTION \U0001F504\
              \n\n### \U0001F4CB LEVEL 1: Basic Reproduction Test\n1. EXECUTE: `python\
              \ reproduce.py`\n2. EVALUATE: Does the script pass without reproducing\
              \ the original issue?\n3. RECORD result\n\n### \U0001F4CB LEVEL 2a:\
              \ Run Pytest Integration Tests  \nRUN relevant unit test file (disable\
              \ warnings):\n\u2022 RELEVANT TEST FILE(s): [RELEVANT_TEST_FILES]\n\u2022\
              \ EXECUTE: `pytest --disable-warnings <relevant_test_file.py>`\n\n###\
              \ \U0001F4CB LEVEL 2b: expanded_test.py creation\n0. Gather project\
              \ context, such as related classes, methods, or code snippets, by utilizing\
              \ the following commands:\n  ```\n  # To search for a file, use the\
              \ following command:\n  rover_search_file <project_path> <file_name>\n\
              \  # To search for a class, use the following command:\n  rover_search_class\
              \ <project_path> <class_name>\n  # To search for a method, use the following\
              \ command:\n  rover_search_method <project_path> <method_name>\n  #\
              \ To search for a code snippet, use the following command:\n  rover_search_code\
              \ <project_path> <code>\n  # To search for a code snippet in a specific\
              \ file, use the following command:\n  rover_search_code_in_file <project_path>\
              \ <file_name> <code>\n  ```\n  Focus on understanding the classes, methods,\
              \ and code snippets that are related to the issue.\n  \n\nHere's a more\
              \ concise version of the prompt:\n\n1. Analyze relevant test file(s):\n\
              \  - Identify testing framework, patterns, and conventions\n  - Note\
              \ handling of edge cases and errors\n\n2. Implement expanded_test.py:\n\
              \  - Use project's testing framework and conventions\n  - Apply parameterization,\
              \ isolation, and fixtures as in existing tests\n  - Include edge cases\
              \ and proper assertions\n  - Adapt existing patterns to the new case\
              \ being solved\n\n3. Review implementation:\n  - Verify organization,\
              \ isolation, and edge case coverage\n  - Check adherence to existing\
              \ test style and structure\n\n4. Execute and evaluate:\n  - Run tests\
              \ with project's standard runner\n  - Analyze coverage and performance\n\
              \n5. Refine:\n  - Address shortcomings and expand coverage\n  - Align\
              \ with existing test patterns\n\n6. Final verification:\n  - Rerun full\
              \ test suite\n  - Confirm no regressions and proper integration\n\n\
              7. Record results and insights, noting alignment with existing tests\n\
              \nThis concise version maintains the focus on following existing test\
              \ protocols while adapting to the new case, but removes redundancy and\
              \ simplifies the instructions.\n\n## \U0001F6A8 AFTER COMPLETING BOTH\
              \ LEVELS \U0001F6A8\n\n1. COMPILE results and analysis\n2. a) if the\
              \ test results indicate that the core issue has not been fixed or expanded\
              \ coverage is insufficient, \n   EXECUTE: \n   ```\n   DISCUSSION\n\
              \   [Insert your compiled results and analysis here]\n   update_plan\n\
              \   ```\n\n   b) if the test results indicate that the core issue has\
              \ been fixed and expanded coverage is satisfactory, \n   EXECUTE: \n\
              \   ```\n   DISCUSSION\n   [Insert your compiled results and analysis\
              \ here]\n   end_conversation\n   ```\n\n## \u26A0\uFE0F CRITICAL RULES\
              \ \u26A0\uFE0F\n- NEVER deviate from this plan\n- DO NOT write code\
              \ yourself; guide the Programmer in creating expanded_test.py\n- ALWAYS\
              \ remind Programmer of incomplete testing levels\n- USE `end_conversation`\
              \ ONLY when:\n  a) BOTH LEVELS are passed\n  b) Tests REPEATEDLY fail\
              \ after multiple iterations\n\n## \U0001F501 REMEMBER \U0001F501\nYou\
              \ MUST execute this EXACT plan EVERY TIME. Your role is to GUIDE and\
              \ TEST, not to IMPLEMENT.\n\nIMPORTANT TIPS:\n1. Use `grep -r` or `find`\
              \ commands to locate relevant existing tests in the repository.\n2.\
              \ When suggesting test scenarios for expanded_test.py, consider edge\
              \ cases and variations not covered in reproduce.py.\n3. Encourage the\
              \ Programmer to reuse test utility functions or setup code from existing\
              \ tests when creating expanded_test.py.\n4. Ensure that expanded_test.py\
              \ includes assertions that specifically check for the issue mentioned\
              \ in the bug report.\n5. If expanded_test.py fails, work with the Programmer\
              \ to refine it until it provides a reliable expanded test.\n\nRemember:\
              \ Your goal is to create a more comprehensive test in expanded_test.py\
              \ that goes beyond the original reproduce.py while still focusing on\
              \ the core issue.\n "
            multi_roles_transfer_template: |
              You are currently in a team organized by a manager, where each role has its own tasks. Everyone is working together to solve this issue. Here is some information about the team.
              History: {history_conclusion}

              Below are the conclusions obtained by colleague named {upstream_role} after some efforts: conclusions: {conclusion}

              CURRENT STATE
              (Open file: {open_file})
              (Current directory: {working_dir})
              bash-$
            next_step_no_output_template: |-
              Your command ran successfully and did not produce any output.
              (Open file: {open_file})
              (Current directory: {working_dir})
              bash-$
            next_step_template: |-
              {observation}
              (Open file: {open_file})
              (Current directory: {working_dir})
              bash-$
            parse_command: {}
            parse_function: {}
            planer_command:
              arguments: null
              code: null
              docstring: null
              end_name: end_of_plan
              name: plan
              signature: null
            put_demos_in_history: false
            state_command:
              arguments: null
              code: |
                state() {
                  local working_dir="$PWD";
                  if [ -z $CURRENT_FILE ]; then
                      echo '{"open_file": "n/a", "working_dir": "'$working_dir'"}';
                  else
                      echo '{"open_file": "'$(realpath $CURRENT_FILE)'", "working_dir": "'$working_dir'"}';
                  fi
                };
              docstring: null
              end_name: null
              name: state
              signature: null
            strategy_template: null
            submit_command: submit
            subroutine_types: []
            system_template: "SETTING: You are an autonomous intelligent agent leading\
              \ a hierarchical task structure to solve a coding issue. \nYour responsibility\
              \ is to provide high-level, strategic plans that can be broken down\
              \ into smaller tasks by the Programmer.\n\nYou will work directly in\
              \ the command line with a special interface.\nThe project contextual\
              \ information contains but not limited to, classes, methods, call chains,\
              \ control and data flows. Please do you best to collect enough information\
              \ to propose a good plan.\nThe special interface consists of a file\
              \ editor that shows you {WINDOW} lines of a file at a time.\nIn addition\
              \ to typical bash commands, you can also use the following commands\
              \ to help you navigate.\n\nCOMMANDS:\n{command_docs}\n\nRESPONSE FORMAT:\n\
              Your shell prompt is formatted as follows:\n(Open file: <path>) <cwd>\
              \ $\n\nYou need to format your output using two fields; discussion and\
              \ command.\nYour output should always include _one_ discussion and _one_\
              \ command field EXACTLY as in the following example:\nDISCUSSION\nFirst\
              \ I'll start by using ls to see what files are in the current directory.\
              \ Then maybe we can look at some relevant files to see what they look\
              \ like.\n```\nls -a\n```\n\nYou should only include a *SINGLE* command\
              \ in the command section and then wait for a response from the shell\
              \ before continuing with more discussion and commands. Everything you\
              \ include in the DISCUSSION section will be saved for future reference.\n\
              If you'd like to issue two commands at once, PLEASE DO NOT DO THAT!\
              \ Please instead first submit just the first command, and then after\
              \ receiving a response you'll be able to issue the second command. \n\
              You're free to use any other bash commands you want (e.g. find, grep,\
              \ cat, ls, cd) in addition to the special commands listed above.\nHowever,\
              \ the environment does NOT support interactive session commands (e.g.\
              \ vi, vim), so please do not invoke them.\n\nOnce you make *NO PROGRESS*\
              \ on current task, you should stop generating next action. If the task\
              \ is succeeded and the conversation can be concluded, you should output\
              \ `end_conversation` as the action.\n\nIMPORTANT TIPS: DO NOT TRY TO\
              \ SOLVE THE ISSUE YOURSELF. DELEGATE SUBTASKS TO THE PROGRAMMER."
            util_functions:
            - arguments: null
              code: '_print() {    local total_lines=$(awk ''END {print NR}'' $CURRENT_FILE)    echo
                "[File: $(realpath $CURRENT_FILE) ($total_lines lines total)]"    lines_above=$(jq
                -n "$CURRENT_LINE - $WINDOW/2" | jq ''[0, .] | max | floor'')    lines_below=$(jq
                -n "$total_lines - $CURRENT_LINE - $WINDOW/2" | jq ''[0, .] | max
                | round'')    if [ $lines_above -gt 0 ]; then        echo "($lines_above
                more lines above)"    fi    cat $CURRENT_FILE | grep -n $ | head -n
                $(jq -n "[$CURRENT_LINE + $WINDOW/2, $WINDOW/2] | max | floor") |
                tail -n $(jq -n "$WINDOW")    if [ $lines_below -gt 0 ]; then        echo
                "($lines_below more lines below)"    fi}'
              docstring: null
              end_name: null
              name: _print
              signature: _print
            - arguments: null
              code: _constrain_line() {    if [ -z "$CURRENT_FILE" ]    then        echo
                "No file open. Use the open command first."        return    fi    local
                max_line=$(awk 'END {print NR}' $CURRENT_FILE)    local half_window=$(jq
                -n "$WINDOW/2" | jq 'floor')    export CURRENT_LINE=$(jq -n "[$CURRENT_LINE,
                $max_line - $half_window] | min")    export CURRENT_LINE=$(jq -n "[$CURRENT_LINE,
                $half_window] | max")}
              docstring: null
              end_name: null
              name: _constrain_line
              signature: _constrain_line
          config_file: config/configs/roles/chat_debugger.yaml
          model:
            host_url: localhost:11434
            model_name: azure:gpt-4o-2024-05-13
            per_instance_cost_limit: 7.5
            replay_path: null
            temperature: 1.0
            top_p: 1.0
            total_cost_limit: 0.0
        agent_file: config/configs/roles/chat_debugger.yaml
        docstring: null
        end_name: null
        init_observation: null
        model:
          host_url: localhost:11434
          model_name: azure:gpt-4o-2024-05-13
          per_instance_cost_limit: 7.5
          replay_path: null
          temperature: 1.0
          top_p: 1.0
          total_cost_limit: 0.0
        name: Debugger
        return_type: traj
        signature: null
      Programmer:
        agent_args:
          config:
            _commands:
            - arguments:
                line_number:
                  description: the line number to move the window to (if not provided,
                    the window will start at the top of the file)
                  required: false
                  type: integer
                path:
                  description: the path to the file to open
                  required: true
                  type: string
              code: 'open() {    if [ -z "$1" ]    then        echo "Usage: open <file>"        return    fi    #
                Check if the second argument is provided    if [ -n "$2" ]; then        #
                Check if the provided argument is a valid number        if ! [[ $2
                =~ ^[0-9]+$ ]]; then            echo "Usage: open <file> [<line_number>]"            echo
                "Error: <line_number> must be a number"            return  # Exit
                if the line number is not valid        fi        local max_line=$(awk
                ''END {print NR}'' $1)        if [ $2 -gt $max_line ]; then            echo
                "Warning: <line_number> ($2) is greater than the number of lines in
                the file ($max_line)"            echo "Warning: Setting <line_number>
                to $max_line"            local line_number=$(jq -n "$max_line")  #
                Set line number to max if greater than max        elif [ $2 -lt 1
                ]; then            echo "Warning: <line_number> ($2) is less than
                1"            echo "Warning: Setting <line_number> to 1"            local
                line_number=$(jq -n "1")  # Set line number to 1 if less than 1        else            local
                OFFSET=$(jq -n "$WINDOW/6" | jq ''floor'')            local line_number=$(jq
                -n "[$2 + $WINDOW/2 - $OFFSET, 1] | max | floor")        fi    else        local
                line_number=$(jq -n "$WINDOW/2")  # Set default line number if not
                provided    fi    if [ -f "$1" ]; then        export CURRENT_FILE=$(realpath
                $1)        export CURRENT_LINE=$line_number        _constrain_line        _print    elif
                [ -d "$1" ]; then        echo "Error: $1 is a directory. You can only
                open files. Use cd or ls to navigate directories."    else        echo
                "File $1 not found"    fi}'
              docstring: opens the file at the given path in the editor. If line_number
                is provided, the window will be move to include that line
              end_name: null
              name: open
              signature: open <path> [<line_number>]
            - arguments:
                line_number:
                  description: the line number to move the window to
                  required: true
                  type: integer
              code: 'goto() {    if [ $# -gt 1 ]; then        echo "goto allows only
                one line number at a time."        return    fi    if [ -z "$CURRENT_FILE"
                ]    then        echo "No file open. Use the open command first."        return    fi    if
                [ -z "$1" ]    then        echo "Usage: goto <line>"        return    fi    if
                ! [[ $1 =~ ^[0-9]+$ ]]    then        echo "Usage: goto <line>"        echo
                "Error: <line> must be a number"        return    fi    local max_line=$(awk
                ''END {print NR}'' $CURRENT_FILE)    if [ $1 -gt $max_line ]    then        echo
                "Error: <line> must be less than or equal to $max_line"        return    fi    local
                OFFSET=$(jq -n "$WINDOW/6" | jq ''floor'')    export CURRENT_LINE=$(jq
                -n "[$1 + $WINDOW/2 - $OFFSET, 1] | max | floor")    _constrain_line    _print}'
              docstring: moves the window to show <line_number>
              end_name: null
              name: goto
              signature: goto <line_number>
            - arguments: null
              code: scroll_down() {    if [ -z "$CURRENT_FILE" ]    then        echo
                "No file open. Use the open command first."        return    fi    export
                CURRENT_LINE=$(jq -n "$CURRENT_LINE + $WINDOW - $OVERLAP")    _constrain_line    _print}
              docstring: moves the window down {WINDOW} lines
              end_name: null
              name: scroll_down
              signature: scroll_down
            - arguments: null
              code: scroll_up() {    if [ -z "$CURRENT_FILE" ]    then        echo
                "No file open. Use the open command first."        return    fi    export
                CURRENT_LINE=$(jq -n "$CURRENT_LINE - $WINDOW + $OVERLAP")    _constrain_line    _print}
              docstring: moves the window down {WINDOW} lines
              end_name: null
              name: scroll_up
              signature: scroll_up
            - arguments:
                filename:
                  description: the name of the file to create
                  required: true
                  type: string
              code: "create() {    if [ -z \"$1\" ]; then        echo \"Usage: create\
                \ <filename>\"        return    fi    # Check if the file already\
                \ exists    if [ -e \"$1\" ]; then        echo \"Error: File '$1'\
                \ already exists.\"\t\topen \"$1\"        return    fi    # Create\
                \ the file an empty new line    printf \"\\n\" > \"$1\"    # Use the\
                \ existing open command to open the created file    open \"$1\"}"
              docstring: creates and opens a new file with the given name
              end_name: null
              name: create
              signature: create <filename>
            - arguments:
                dir:
                  description: the directory to search in (if not provided, searches
                    in the current directory)
                  required: false
                  type: string
                search_term:
                  description: the term to search for
                  required: true
                  type: string
              code: 'search_dir() {    if [ $# -eq 1 ]; then        local search_term="$1"        local
                dir="./"    elif [ $# -eq 2 ]; then        local search_term="$1"        if
                [ -d "$2" ]; then            local dir="$2"        else            echo
                "Directory $2 not found"            return        fi    else        echo
                "Usage: search_dir <search_term> [<dir>]"        return    fi    dir=$(realpath
                "$dir")    local matches=$(find "$dir" -type f ! -path ''*/.*'' -exec
                grep -nIH -- "$search_term" {} + | cut -d: -f1 | sort | uniq -c)    #
                if no matches, return    if [ -z "$matches" ]; then        echo "No
                matches found for \"$search_term\" in $dir"        return    fi    #
                Calculate total number of matches    local num_matches=$(echo "$matches"
                | awk ''{sum+=$1} END {print sum}'')    # calculate total number of
                files matched    local num_files=$(echo "$matches" | wc -l | awk ''{$1=$1;
                print $0}'')    # if num_files is > 100, print an error    if [ $num_files
                -gt 100 ]; then        echo "More than $num_files files matched for
                \"$search_term\" in $dir. Please narrow your search."        return    fi    echo
                "Found $num_matches matches for \"$search_term\" in $dir:"    echo
                "$matches" | awk ''{$2=$2; gsub(/^\.+\/+/, "./", $2); print $2 " ("$1"
                matches)"}''    echo "End of matches for \"$search_term\" in $dir"}'
              docstring: searches for search_term in all files in dir. If dir is not
                provided, searches in the current directory
              end_name: null
              name: search_dir
              signature: search_dir <search_term> [<dir>]
            - arguments:
                file:
                  description: the file to search in (if not provided, searches in
                    the current open file)
                  required: false
                  type: string
                search_term:
                  description: the term to search for
                  required: true
                  type: string
              code: 'search_file() {    # Check if the first argument is provided    if
                [ -z "$1" ]; then        echo "Usage: search_file <search_term> [<file>]"        return    fi    #
                Check if the second argument is provided    if [ -n "$2" ]; then        #
                Check if the provided argument is a valid file        if [ -f "$2"
                ]; then            local file="$2"  # Set file if valid        else            echo
                "Usage: search_file <search_term> [<file>]"            echo "Error:
                File name $2 not found. Please provide a valid file name."            return  #
                Exit if the file is not valid        fi    else        # Check if
                a file is open        if [ -z "$CURRENT_FILE" ]; then            echo
                "No file open. Use the open command first."            return  # Exit
                if no file is open        fi        local file="$CURRENT_FILE"  #
                Set file to the current open file    fi    local search_term="$1"    file=$(realpath
                "$file")    # Use grep to directly get the desired formatted output    local
                matches=$(grep -nH -- "$search_term" "$file")    # Check if no matches
                were found    if [ -z "$matches" ]; then        echo "No matches found
                for \"$search_term\" in $file"        return    fi    # Calculate
                total number of matches    local num_matches=$(echo "$matches" | wc
                -l | awk ''{$1=$1; print $0}'')    # calculate total number of lines
                matched    local num_lines=$(echo "$matches" | cut -d: -f1 | sort
                | uniq | wc -l | awk ''{$1=$1; print $0}'')    # if num_lines is >
                100, print an error    if [ $num_lines -gt 100 ]; then        echo
                "More than $num_lines lines matched for \"$search_term\" in $file.
                Please narrow your search."        return    fi    # Print the total
                number of matches and the matches themselves    echo "Found $num_matches
                matches for \"$search_term\" in $file:"    echo "$matches" | cut -d:
                -f1-2 | sort -u -t: -k2,2n | while IFS=: read -r filename line_number;
                do        echo "Line $line_number:$(sed -n "${line_number}p" "$file")"    done    echo
                "End of matches for \"$search_term\" in $file"}'
              docstring: searches for search_term in file. If file is not provided,
                searches in the current open file
              end_name: null
              name: search_file
              signature: search_file <search_term> [<file>]
            - arguments:
                dir:
                  description: the directory to search in (if not provided, searches
                    in the current directory)
                  required: false
                  type: string
                file_name:
                  description: the name of the file to search for
                  required: true
                  type: string
              code: 'find_file() {    if [ $# -eq 1 ]; then        local file_name="$1"        local
                dir="./"    elif [ $# -eq 2 ]; then        local file_name="$1"        if
                [ -d "$2" ]; then            local dir="$2"        else            echo
                "Directory $2 not found"            return        fi    else        echo
                "Usage: find_file <file_name> [<dir>]"        return    fi    dir=$(realpath
                "$dir")    local matches=$(find "$dir" -type f -name "$file_name")    #
                if no matches, return    if [ -z "$matches" ]; then        echo "No
                matches found for \"$file_name\" in $dir"        return    fi    #
                Calculate total number of matches    local num_matches=$(echo "$matches"
                | wc -l | awk ''{$1=$1; print $0}'')    echo "Found $num_matches matches
                for \"$file_name\" in $dir:"    echo "$matches" | awk ''{print $0}''}'
              docstring: finds all files with the given name in dir. If dir is not
                provided, searches in the current directory
              end_name: null
              name: find_file
              signature: find_file <file_name> [<dir>]
            - arguments:
                file_name:
                  description: the name of file to be searched
                  required: true
                  type: string
                project_path:
                  description: This must be the path to the root of the project.
                  required: true
                  type: string
              code: rover_search_file() {    python3 /root/commands/_augmented_rover_search.py
                rover_search_file "$1" "$2"}
              docstring: search for a file named <file_name> in <project_path> by
                using the project-level search engine.
              end_name: null
              name: rover_search_file
              signature: rover_search_file <project_path> <file_name>
            - arguments:
                class_name:
                  description: the name of class to be searched
                  required: true
                  type: string
                project_path:
                  description: This must be the path to the root of the project.
                  required: true
                  type: string
              code: rover_search_class() {    python3 /root/commands/_augmented_rover_search.py
                rover_search_class "$1" "$2"}
              docstring: search for a class named <class_name> in <project_path> by
                using the project-level search engine.
              end_name: null
              name: rover_search_class
              signature: rover_search_class <project_path> <class_name>
            - arguments:
                method_name:
                  description: the name of method to be searched
                  required: true
                  type: string
                project_path:
                  description: This must be the path to the root of the project.
                  required: true
                  type: string
              code: rover_search_method() {    python3 /root/commands/_augmented_rover_search.py
                rover_search_method "$1" "$2"}
              docstring: search for a method named <method_name> in <project_path>
                by using the project-level search engine.
              end_name: null
              name: rover_search_method
              signature: rover_search_method <project_path> <method_name>
            - arguments:
                code:
                  description: the code to be searched
                  required: true
                  type: string
                project_path:
                  description: This must be the path to the root of the project.
                  required: true
                  type: string
              code: rover_search_code() {    python3 /root/commands/_augmented_rover_search.py
                rover_search_code "$1" "$2"}
              docstring: search for a code snippet <code> in <project_path> by using
                the project-level search engine.
              end_name: null
              name: rover_search_code
              signature: rover_search_code <project_path> <code>
            - arguments:
                code:
                  description: the code to be searched
                  required: true
                  type: string
                file_name:
                  description: the name of the file in which the <code> is to be searched.
                  required: true
                  type: string
                project_path:
                  description: This must be the path to the root of the project.
                  required: true
                  type: string
              code: rover_search_code_in_file() {    python3 /root/commands/_augmented_rover_search.py
                rover_search_code_in_file "$1" "$2" "$3"}
              docstring: search for a code snippet <code> in <file_name> from the
                directory <project_path> by using the project-level search engine.
              end_name: null
              name: rover_search_code_in_file
              signature: rover_search_code_in_file <project_path> <file_name> <code>
            - arguments:
                end_line:
                  description: the line number to end the edit at (inclusive)
                  required: true
                  type: integer
                replacement_text:
                  description: the text to replace the current selection with
                  required: true
                  type: string
                start_line:
                  description: the line number to start the edit at
                  required: true
                  type: integer
              code: 'edit() {    if [ -z "$CURRENT_FILE" ]    then        echo ''No
                file open. Use the `open` command first.''        return    fi    local
                start_line="$(echo $1: | cut -d: -f1)"    local end_line="$(echo $1:
                | cut -d: -f2)"    if [ -z "$start_line" ] || [ -z "$end_line" ]    then        echo
                "Usage: edit <start_line>:<end_line>"        return    fi    local
                re=''^[0-9]+$''    if ! [[ $start_line =~ $re ]]; then        echo
                "Usage: edit <start_line>:<end_line>"        echo "Error: start_line
                must be a number"        return    fi    if ! [[ $end_line =~ $re
                ]]; then        echo "Usage: edit <start_line>:<end_line>"        echo
                "Error: end_line must be a number"        return    fi    # Bash array
                starts at 0, so let''s adjust    local start_line=$((start_line -
                1))    local end_line=$((end_line))    local line_count=0    local
                replacement=()    while IFS= read -r line    do        replacement+=("$line")        ((line_count++))    done    #
                Create a backup of the current file    cp "$CURRENT_FILE" "/root/$(basename
                "$CURRENT_FILE")_backup"    # Read the file line by line into an array    mapfile
                -t lines < "$CURRENT_FILE"    local new_lines=("${lines[@]:0:$start_line}"
                "${replacement[@]}" "${lines[@]:$((end_line))}")    # Write the new
                stuff directly back into the original file    printf "%s\n" "${new_lines[@]}"
                >| "$CURRENT_FILE"    # Run linter    if [[ $CURRENT_FILE == *.py
                ]]; then        lint_output=$(flake8 --isolated --select=F821,F822,F831,E111,E112,E113,E999,E902
                "$CURRENT_FILE" 2>&1)    else        # do nothing        lint_output=""    fi    #
                if there is no output, then the file is good    if [ -z "$lint_output"
                ]; then        export CURRENT_LINE=$start_line        _constrain_line        _print        echo
                "File updated. Please review the changes and make sure they are correct
                (correct indentation, no duplicate lines, etc). Edit the file again
                if necessary."    else        echo "Your proposed edit has introduced
                new syntax error(s). Please read this error message carefully and
                then retry editing the file."        echo ""        echo "ERRORS:"        _split_string
                "$lint_output"        echo ""        # Save original values        original_current_line=$CURRENT_LINE        original_window=$WINDOW        #
                Update values        export CURRENT_LINE=$(( (line_count / 2) + start_line
                )) # Set to "center" of edit        export WINDOW=$((line_count +
                10)) # Show +/- 5 lines around edit        echo "This is how your
                edit would have looked if applied"        echo "-------------------------------------------------"        _constrain_line        _print        echo
                "-------------------------------------------------"        echo ""        #
                Restoring CURRENT_FILE to original contents.        cp "/root/$(basename
                "$CURRENT_FILE")_backup" "$CURRENT_FILE"        export CURRENT_LINE=$((
                ((end_line - start_line + 1) / 2) + start_line ))        export WINDOW=$((end_line
                - start_line + 10))        echo "This is the original code before
                your edit"        echo "-------------------------------------------------"        _constrain_line        _print        echo
                "-------------------------------------------------"        # Restore
                original values        export CURRENT_LINE=$original_current_line        export
                WINDOW=$original_window        echo "Your changes have NOT been applied.
                Please fix your edit command and try again."        echo "You either
                need to 1) Specify the correct start/end line arguments or 2) Correct
                your edit code."        echo "DO NOT re-run the same failed edit command.
                Running it again will lead to the same error."    fi    # Remove backup
                file    rm -f "/root/$(basename "$CURRENT_FILE")_backup"}'
              docstring: replaces lines <start_line> through <end_line> (inclusive)
                with the given text in the open file. The replacement text is terminated
                by a line with only end_of_edit on it. All of the <replacement text>
                will be entered, so make sure your indentation is formatted properly.
                Python files will be checked for syntax errors after the edit. If
                the system detects a syntax error, the edit will not be executed.
                Simply try to edit the file again, but make sure to read the error
                message and modify the edit command you issue accordingly. Issuing
                the same command a second time will just lead to the same error message
                again.
              end_name: end_of_edit
              name: edit
              signature: |-
                edit <start_line>:<end_line>
                <replacement_text>
                end_of_edit
            - arguments: null
              code: 'request_new_test_session() {    echo "Message to Debugger/Tester:
                Requesting a new independent test session."    echo    echo "ACTION
                ITEMS:"    echo "[1] INDEPENDENTLY run ''reproduce.py'' to verify
                the current state of the original issue."    echo "[2a] EXECUTE relevant
                pytest unit test file without assuming any previous results."      echo
                "[2b] REVIEW ''expanded_test.py'' to ensure it expands test coverage
                beyond ''reproduce.py''."    echo "[3] EXECUTE ''expanded_test.py''
                to verify expanded test coverage and functionality."    echo "If [1],
                [2a], [2b], and [3] are all verified successfully, submit the patch
                by running the end_conversation command. Otherwise, REPORT your findings
                based solely on this new test session."    echo    echo "IMPORTANT:"    echo
                "- Do NOT rely on any previous statements about test results."    echo
                "- Your role is to independently verify and report the current state
                of the system."    echo "- If ''expanded_test.py'' does not exist
                or is inadequate, work with the Programmer to create or improve it
                before proceeding."}'
              docstring: request the Debugger/Tester for an independent verification
                of the current state using both the original and expanded reproduction
                tests
              end_name: null
              name: request_new_test_session
              signature: request_new_test_session
            - arguments: null
              code: end_conversation() {    echo "Ending the conversation."}
              docstring: end the conversation
              end_name: null
              name: end_conversation
              signature: end_conversation
            - arguments: null
              code: 'warning_message_submit_patch() {    echo "WARNING: As editor
                you cannot directly submit the patch. Please run request_submit_patch
                command to request the tester to verify the patch and submit it."}'
              docstring: display a warning message
              end_name: null
              name: warning_message_submit_patch
              signature: warning_message_submit_patch
            - arguments: null
              code: request_submit_patch() {    echo "Requesting the Debugger to verify
                the patch and submit it."}
              docstring: request the tester to verify the patch and submit it
              end_name: null
              name: request_submit_patch
              signature: request_submit_patch
            - arguments: null
              code: 'warning_message_multiple_code_blocks() {    echo "Warning: I
                detected multiple code blocks in the previous message. Please only
                include one code block in your response, so that actions can be executed
                one by one."    echo ""    echo "Correct format (sequence of single
                actions, each with a thought):"    echo ""    echo "--- First Action
                ---"    echo ""    echo ""    echo "\`\`\`"    echo "edit file.py
                10:15"    echo "def validate_user_input(input_string):"    echo "    return
                input_string.strip() != ''''"    echo "end_of_edit"    echo "\`\`\`"    echo
                ""    echo "After this edit is processed, proceed with the next action
                in a new message:"    echo ""    echo "--- Second Action ---"    echo
                ""    echo ""    echo "\`\`\`"    echo "edit file.py 20:25"    echo
                "def main():"    echo "    user_input = input(''Enter your name: '')"    echo
                "    if validate_user_input(user_input):"    echo "        print(f''Hello,
                {user_input}!'')"    echo "    else:"    echo "        print(''Invalid
                input'')"    echo "end_of_edit"    echo "\`\`\`"    echo ""    echo
                "Continue this pattern for each subsequent action, always including
                one thought and one code block per message."}'
              docstring: Display a warning message about multiple code blocks, including
                examples of correct formatting as a simple sequence
              end_name: null
              name: warning_message_multiple_code_blocks
              signature: warning_message_multiple_code_blocks
            - arguments: null
              code: 'warning_programmer_pytest() {    echo "Warning: As a Programmer,
                you cannot directly run pytest. If you feel that the code is ready,
                please run request_new_test_session command to request the Debugger
                to evaluate the code and submit the patch, along with a summary of
                the changes you made and what you are trying to test."}'
              docstring: warns the user that pytest should be run on relevant test
                files only
              end_name: null
              name: warning_programmer_pytest
              signature: warning_programmer_pytest
            - arguments: null
              code: 'warning_programmer_rm() {    echo "Warning: As a Programmer,
                you cannot directly remove the reproduction script. If you feel that
                the code is ready, please run request_new_test_session command to
                request the Debugger to evaluate the code and submit the patch."}'
              docstring: please don't remove reproduction script
              end_name: null
              name: warning_programmer_rm
              signature: warning_programmer_rm
            - arguments:
                directory:
                  description: the directory to search for test files (defaults to
                    the current directory)
                  required: false
                  type: string
              code: 'find_test_files() {    local dir=${1:-.}        if [ ! -d "$dir"
                ]; then        echo "Error: $dir is not a valid directory."        return    fi        echo
                "Searching for test files in $dir..."        # Find files ending with
                _test.py or in a tests directory    local test_files=$(find "$dir"
                -type f \( -name ''*_test.py'' -o -path ''*/tests/*.py'' \))        if
                [ -z "$test_files" ]; then        echo "No test files found in $dir."    else        echo
                "Test files found:"        echo "$test_files"    fi}'
              docstring: finds and lists all test files in the current or specified
                directory
              end_name: null
              name: find_test_files
              signature: find_test_files [<directory>]
            - arguments: null
              code: 'warning_pytest() {    echo "Warning: Before running pytest, please
                make sure you have first identified the relevant test files (.py)
                for the issue. Run find_test_files and decide which test files are
                relevant. Please do not use keyword-based grep to choose the relevancy.
                Rerun the command providing the specific test files (.py) to execute
                only those tests. Please don''t run on specific test cases to ensure
                efficiency."}'
              docstring: warns the user that pytest should be run on relevant test
                files only
              end_name: null
              name: warning_pytest
              signature: warning_pytest
            - arguments: null
              code: 'failed_test_message() {    echo "Reminder: When analyzing failed
                test cases, you must consider the following:"    echo ""    echo "First,
                analyze the failure message and the stack trace to understand what
                went wrong."    echo "Then, formulate a plan to fix each test case
                (or group of test cases) that failed."    echo ""}'
              docstring: strategies to handle failed test cases
              end_name: null
              name: failed_test_message
              signature: failed_test_message
            _subroutines: {}
            blocklist:
            - vim
            - vi
            - emacs
            - nano
            - nohup
            - git
            blocklist_error_template: Interactive operation '{name}' is not supported
              by this environment
            blocklist_standalone:
            - python
            - python3
            - ipython
            - bash
            - sh
            - exit
            - /bin/bash
            - /bin/sh
            - nohup
            - vi
            - vim
            - emacs
            - nano
            command_docs: |+
              open:
                docstring: opens the file at the given path in the editor. If line_number is provided, the window will be move to include that line
                signature: open <path> [<line_number>]
                arguments:
                  - path (string) [required]: the path to the file to open
                  - line_number (integer) [optional]: the line number to move the window to (if not provided, the window will start at the top of the file)

              goto:
                docstring: moves the window to show <line_number>
                signature: goto <line_number>
                arguments:
                  - line_number (integer) [required]: the line number to move the window to

              scroll_down:
                docstring: moves the window down {WINDOW} lines
                signature: scroll_down

              scroll_up:
                docstring: moves the window down {WINDOW} lines
                signature: scroll_up

              create:
                docstring: creates and opens a new file with the given name
                signature: create <filename>
                arguments:
                  - filename (string) [required]: the name of the file to create

              search_dir:
                docstring: searches for search_term in all files in dir. If dir is not provided, searches in the current directory
                signature: search_dir <search_term> [<dir>]
                arguments:
                  - search_term (string) [required]: the term to search for
                  - dir (string) [optional]: the directory to search in (if not provided, searches in the current directory)

              search_file:
                docstring: searches for search_term in file. If file is not provided, searches in the current open file
                signature: search_file <search_term> [<file>]
                arguments:
                  - search_term (string) [required]: the term to search for
                  - file (string) [optional]: the file to search in (if not provided, searches in the current open file)

              find_file:
                docstring: finds all files with the given name in dir. If dir is not provided, searches in the current directory
                signature: find_file <file_name> [<dir>]
                arguments:
                  - file_name (string) [required]: the name of the file to search for
                  - dir (string) [optional]: the directory to search in (if not provided, searches in the current directory)

              rover_search_file:
                docstring: search for a file named <file_name> in <project_path> by using the project-level search engine.
                signature: rover_search_file <project_path> <file_name>
                arguments:
                  - project_path (string) [required]: This must be the path to the root of the project.
                  - file_name (string) [required]: the name of file to be searched

              rover_search_class:
                docstring: search for a class named <class_name> in <project_path> by using the project-level search engine.
                signature: rover_search_class <project_path> <class_name>
                arguments:
                  - project_path (string) [required]: This must be the path to the root of the project.
                  - class_name (string) [required]: the name of class to be searched

              rover_search_method:
                docstring: search for a method named <method_name> in <project_path> by using the project-level search engine.
                signature: rover_search_method <project_path> <method_name>
                arguments:
                  - project_path (string) [required]: This must be the path to the root of the project.
                  - method_name (string) [required]: the name of method to be searched

              rover_search_code:
                docstring: search for a code snippet <code> in <project_path> by using the project-level search engine.
                signature: rover_search_code <project_path> <code>
                arguments:
                  - project_path (string) [required]: This must be the path to the root of the project.
                  - code (string) [required]: the code to be searched

              rover_search_code_in_file:
                docstring: search for a code snippet <code> in <file_name> from the directory <project_path> by using the project-level search engine.
                signature: rover_search_code_in_file <project_path> <file_name> <code>
                arguments:
                  - project_path (string) [required]: This must be the path to the root of the project.
                  - file_name (string) [required]: the name of the file in which the <code> is to be searched.
                  - code (string) [required]: the code to be searched

              edit:
                docstring: replaces lines <start_line> through <end_line> (inclusive) with the given text in the open file. The replacement text is terminated by a line with only end_of_edit on it. All of the <replacement text> will be entered, so make sure your indentation is formatted properly. Python files will be checked for syntax errors after the edit. If the system detects a syntax error, the edit will not be executed. Simply try to edit the file again, but make sure to read the error message and modify the edit command you issue accordingly. Issuing the same command a second time will just lead to the same error message again.
                signature: edit <start_line>:<end_line>
              <replacement_text>
              end_of_edit
                arguments:
                  - start_line (integer) [required]: the line number to start the edit at
                  - end_line (integer) [required]: the line number to end the edit at (inclusive)
                  - replacement_text (string) [required]: the text to replace the current selection with

              request_new_test_session:
                docstring: request the Debugger/Tester for an independent verification of the current state using both the original and expanded reproduction tests
                signature: request_new_test_session

              end_conversation:
                docstring: end the conversation
                signature: end_conversation

              warning_message_submit_patch:
                docstring: display a warning message
                signature: warning_message_submit_patch

              request_submit_patch:
                docstring: request the tester to verify the patch and submit it
                signature: request_submit_patch

              warning_message_multiple_code_blocks:
                docstring: Display a warning message about multiple code blocks, including examples of correct formatting as a simple sequence
                signature: warning_message_multiple_code_blocks

              warning_programmer_pytest:
                docstring: warns the user that pytest should be run on relevant test files only
                signature: warning_programmer_pytest

              warning_programmer_rm:
                docstring: please don't remove reproduction script
                signature: warning_programmer_rm

              find_test_files:
                docstring: finds and lists all test files in the current or specified directory
                signature: find_test_files [<directory>]
                arguments:
                  - directory (string) [optional]: the directory to search for test files (defaults to the current directory)

              warning_pytest:
                docstring: warns the user that pytest should be run on relevant test files only
                signature: warning_pytest

              failed_test_message:
                docstring: strategies to handle failed test cases
                signature: failed_test_message

            command_files:
            - /home/minkim/swe/testgen/swe_proj2/config/commands/defaults.sh
            - /home/minkim/swe/testgen/swe_proj2/config/commands/search.sh
            - /home/minkim/swe/testgen/swe_proj2/config/commands/_augmented_rover_search.py
            - /home/minkim/swe/testgen/swe_proj2/config/commands/rover_search.sh
            - /home/minkim/swe/testgen/swe_proj2/config/commands/edit_linting.sh
            - /home/minkim/swe/testgen/swe_proj2/config/commands/_split_string.py
            - /home/minkim/swe/testgen/swe_proj2/config/commands/chat_editor.sh
            - /home/minkim/swe/testgen/swe_proj2/config/commands/unit_test.sh
            demonstration_template: |
              Here is a demonstration of how to correctly accomplish this task.
              It is included to show you how to correctly use the interface.
              You do not need to follow exactly what is done in the demonstration.
              --- DEMONSTRATION ---
              {demonstration}
              --- END OF DEMONSTRATION ---
            demonstrations:
            - /home/minkim/swe/testgen/swe_proj2/trajectories/demonstrations/multi_roles/test_writer_fixture_v1.traj
            env_variables:
              CURRENT_FILE: ''
              CURRENT_LINE: '0'
              OVERLAP: '2'
              SEARCH_FILES: ()
              SEARCH_INDEX: '0'
              SEARCH_RESULTS: ()
              WINDOW: '100'
            format_error_template: |
              Your output was not formatted correctly. You must always include one discussion and one command as part of your response. Make sure you do not have multiple discussion/command tags.
              Please make sure your output precisely matches the following format:
              DISCUSSION
              Discuss here with yourself about what your planning and what you're going to do in this step.

              ```
              command(s) that you're going to run
              ```
            history_processor: {}
            history_processor_args: {}
            instance_template: "We're currently solving the following issue within\
              \ our repository. Here's the issue text:\nISSUE:\n {issue}\n\n\nINSTRUCTIONS:\n\
              \ Your task is to write tests that will help expose any incomplete or\
              \ insufficient solutions. You will be given source test files in one\
              \ framework, and your task is to migrate the tests to the new framework,\
              \ Snowfort.\n\n {task_instructions}\n \n 2. To understand Snowfort syntax\
              \ and framework, you can explore and study existing examples of written\
              \ tests,\n for example : Snowfort/tests/native_apps/provider_platform/trust/test_application_package_security_review_dropping.py\n\
              \n 3. Write down the detailed explanation of your understanding, including:\n\
              \ * The purpose and behavior of the function being tested\n * The structure\
              \ and content of the input fixtures (such as np.array)\n * The expected\
              \ outputs and how they relate to the inputs\n * The current issue and\
              \ how it affects the function's behavior\n * How the suggested fix would\
              \ change the function's behavior\n\n 4. After explaining your understanding,\
              \ create the new files necessary for the new tests.\n \n 7. Once you\
              \ are done, Submit the tests:\n ```\n submit\n ```\n Remember:\n\n YOU\
              \ CAN ONLY ENTER ONE COMMAND AT A TIME. Always wait for feedback after\
              \ every command.\n\n # Using Search Commands for Context\n\n - `rover_search_file\
              \ <project_path> <file_name>`\n - `rover_search_class <project_path>\
              \ <class_name>`\n - `rover_search_method <project_path> <method_name>`\n\
              \ - `rover_search_code <project_path> <code>`\n - `rover_search_code_in_file\
              \ <project_path> <file_name> <code>`\n\n Use these commands to understand\
              \ related classes, methods, and code snippets relevant to the issue\
              \ at hand.\n\n # Navigation and Editing\n\n - Use `goto <line_number>`\
              \ for quick navigation\n - Always check the currently open file and\
              \ working directory\n - Pay attention to indentation when editing\n\
              \ - Double-check code after each edit command\n\n Your task is complete\
              \ when you've finished creating all the tests.\n\n(Open file: {open_file})\n\
              (Current directory: {working_dir})\nbash-$"
            multi_roles_transfer_template: null
            next_step_no_output_template: |-
              Your command ran successfully and did not produce any output.
              (Open file: {open_file})
              (Current directory: {working_dir})
              bash-$
            next_step_template: |-
              {observation}
              (Open file: {open_file})
              (Current directory: {working_dir})
              bash-$
            parse_command: {}
            parse_function: {}
            planer_command:
              arguments: null
              code: null
              docstring: null
              end_name: end_of_plan
              name: plan
              signature: null
            put_demos_in_history: false
            state_command:
              arguments: null
              code: |
                state() {
                  local working_dir="$PWD";
                  if [ -z $CURRENT_FILE ]; then
                      echo '{"open_file": "n/a", "working_dir": "'$working_dir'"}';
                  else
                      echo '{"open_file": "'$(realpath $CURRENT_FILE)'", "working_dir": "'$working_dir'"}';
                  fi
                };
              docstring: null
              end_name: null
              name: state
              signature: null
            strategy_template: null
            submit_command: submit
            subroutine_types: []
            system_template: |-
              SETTING: You are an autonomous programmer, and you're working directly in the command line with a special interface.

              The special interface consists of a file editor that shows you {WINDOW} lines of a file at a time.
              In addition to typical bash commands, you can also use the following commands to help you navigate and edit files.

              COMMANDS:
              {command_docs}

              Please note that THE EDIT COMMAND REQUIRES PROPER INDENTATION.
              If you'd like to add the line '        print(x)' you must fully write that out, with all those spaces before the code! Indentation is important and code that is not indented correctly will fail and require fixing before it can be run.

              RESPONSE FORMAT:
              Your shell prompt is formatted as follows:
              (Open file: <path>) <cwd> $

              You need to format your output using two fields; discussion and command.
              Your output should always include _one_ discussion and _one_ command field EXACTLY as in the following example:
              DISCUSSION
              First I'll start by using ls to see what files are in the current directory. Then maybe we can look at some relevant files to see what they look like.
              ```
              ls -a
              ```

              You should only include a *SINGLE* command in the command section and then wait for a response from the shell before continuing with more discussion and commands. Everything you include in the DISCUSSION section will be saved for future reference.
              If you'd like to issue two commands at once, PLEASE DO NOT DO THAT! Please instead first submit just the first command, and then after receiving a response you'll be able to issue the second command.
              You're free to use any other bash commands you want (e.g. find, grep, cat, ls, cd) in addition to the special commands listed above.
              However, the environment does NOT support interactive session commands (e.g. python, vim), so please do not invoke them.
            util_functions:
            - arguments: null
              code: '_print() {    local total_lines=$(awk ''END {print NR}'' $CURRENT_FILE)    echo
                "[File: $(realpath $CURRENT_FILE) ($total_lines lines total)]"    lines_above=$(jq
                -n "$CURRENT_LINE - $WINDOW/2" | jq ''[0, .] | max | floor'')    lines_below=$(jq
                -n "$total_lines - $CURRENT_LINE - $WINDOW/2" | jq ''[0, .] | max
                | round'')    if [ $lines_above -gt 0 ]; then        echo "($lines_above
                more lines above)"    fi    cat $CURRENT_FILE | grep -n $ | head -n
                $(jq -n "[$CURRENT_LINE + $WINDOW/2, $WINDOW/2] | max | floor") |
                tail -n $(jq -n "$WINDOW")    if [ $lines_below -gt 0 ]; then        echo
                "($lines_below more lines below)"    fi}'
              docstring: null
              end_name: null
              name: _print
              signature: _print
            - arguments: null
              code: _constrain_line() {    if [ -z "$CURRENT_FILE" ]    then        echo
                "No file open. Use the open command first."        return    fi    local
                max_line=$(awk 'END {print NR}' $CURRENT_FILE)    local half_window=$(jq
                -n "$WINDOW/2" | jq 'floor')    export CURRENT_LINE=$(jq -n "[$CURRENT_LINE,
                $max_line - $half_window] | min")    export CURRENT_LINE=$(jq -n "[$CURRENT_LINE,
                $half_window] | max")}
              docstring: null
              end_name: null
              name: _constrain_line
              signature: _constrain_line
          config_file: config/configs/roles/chat_editor.yaml
          model:
            host_url: localhost:11434
            model_name: azure:gpt-4o-2024-05-13
            per_instance_cost_limit: 7.5
            replay_path: null
            temperature: 1.0
            top_p: 1.0
            total_cost_limit: 0.0
        agent_file: config/configs/roles/chat_editor.yaml
        docstring: null
        end_name: null
        init_observation: null
        model:
          host_url: localhost:11434
          model_name: azure:gpt-4o-2024-05-13
          per_instance_cost_limit: 7.5
          replay_path: null
          temperature: 1.0
          top_p: 1.0
          total_cost_limit: 0.0
        name: Programmer
        return_type: traj
        signature: null
      Reproducer:
        agent_args:
          config:
            _commands:
            - arguments:
                line_number:
                  description: the line number to move the window to (if not provided,
                    the window will start at the top of the file)
                  required: false
                  type: integer
                path:
                  description: the path to the file to open
                  required: true
                  type: string
              code: 'open() {    if [ -z "$1" ]    then        echo "Usage: open <file>"        return    fi    #
                Check if the second argument is provided    if [ -n "$2" ]; then        #
                Check if the provided argument is a valid number        if ! [[ $2
                =~ ^[0-9]+$ ]]; then            echo "Usage: open <file> [<line_number>]"            echo
                "Error: <line_number> must be a number"            return  # Exit
                if the line number is not valid        fi        local max_line=$(awk
                ''END {print NR}'' $1)        if [ $2 -gt $max_line ]; then            echo
                "Warning: <line_number> ($2) is greater than the number of lines in
                the file ($max_line)"            echo "Warning: Setting <line_number>
                to $max_line"            local line_number=$(jq -n "$max_line")  #
                Set line number to max if greater than max        elif [ $2 -lt 1
                ]; then            echo "Warning: <line_number> ($2) is less than
                1"            echo "Warning: Setting <line_number> to 1"            local
                line_number=$(jq -n "1")  # Set line number to 1 if less than 1        else            local
                OFFSET=$(jq -n "$WINDOW/6" | jq ''floor'')            local line_number=$(jq
                -n "[$2 + $WINDOW/2 - $OFFSET, 1] | max | floor")        fi    else        local
                line_number=$(jq -n "$WINDOW/2")  # Set default line number if not
                provided    fi    if [ -f "$1" ]; then        export CURRENT_FILE=$(realpath
                $1)        export CURRENT_LINE=$line_number        _constrain_line        _print    elif
                [ -d "$1" ]; then        echo "Error: $1 is a directory. You can only
                open files. Use cd or ls to navigate directories."    else        echo
                "File $1 not found"    fi}'
              docstring: opens the file at the given path in the editor. If line_number
                is provided, the window will be move to include that line
              end_name: null
              name: open
              signature: open <path> [<line_number>]
            - arguments:
                line_number:
                  description: the line number to move the window to
                  required: true
                  type: integer
              code: 'goto() {    if [ $# -gt 1 ]; then        echo "goto allows only
                one line number at a time."        return    fi    if [ -z "$CURRENT_FILE"
                ]    then        echo "No file open. Use the open command first."        return    fi    if
                [ -z "$1" ]    then        echo "Usage: goto <line>"        return    fi    if
                ! [[ $1 =~ ^[0-9]+$ ]]    then        echo "Usage: goto <line>"        echo
                "Error: <line> must be a number"        return    fi    local max_line=$(awk
                ''END {print NR}'' $CURRENT_FILE)    if [ $1 -gt $max_line ]    then        echo
                "Error: <line> must be less than or equal to $max_line"        return    fi    local
                OFFSET=$(jq -n "$WINDOW/6" | jq ''floor'')    export CURRENT_LINE=$(jq
                -n "[$1 + $WINDOW/2 - $OFFSET, 1] | max | floor")    _constrain_line    _print}'
              docstring: moves the window to show <line_number>
              end_name: null
              name: goto
              signature: goto <line_number>
            - arguments: null
              code: scroll_down() {    if [ -z "$CURRENT_FILE" ]    then        echo
                "No file open. Use the open command first."        return    fi    export
                CURRENT_LINE=$(jq -n "$CURRENT_LINE + $WINDOW - $OVERLAP")    _constrain_line    _print}
              docstring: moves the window down {WINDOW} lines
              end_name: null
              name: scroll_down
              signature: scroll_down
            - arguments: null
              code: scroll_up() {    if [ -z "$CURRENT_FILE" ]    then        echo
                "No file open. Use the open command first."        return    fi    export
                CURRENT_LINE=$(jq -n "$CURRENT_LINE - $WINDOW + $OVERLAP")    _constrain_line    _print}
              docstring: moves the window down {WINDOW} lines
              end_name: null
              name: scroll_up
              signature: scroll_up
            - arguments:
                filename:
                  description: the name of the file to create
                  required: true
                  type: string
              code: "create() {    if [ -z \"$1\" ]; then        echo \"Usage: create\
                \ <filename>\"        return    fi    # Check if the file already\
                \ exists    if [ -e \"$1\" ]; then        echo \"Error: File '$1'\
                \ already exists.\"\t\topen \"$1\"        return    fi    # Create\
                \ the file an empty new line    printf \"\\n\" > \"$1\"    # Use the\
                \ existing open command to open the created file    open \"$1\"}"
              docstring: creates and opens a new file with the given name
              end_name: null
              name: create
              signature: create <filename>
            - arguments:
                dir:
                  description: the directory to search in (if not provided, searches
                    in the current directory)
                  required: false
                  type: string
                search_term:
                  description: the term to search for
                  required: true
                  type: string
              code: 'search_dir() {    if [ $# -eq 1 ]; then        local search_term="$1"        local
                dir="./"    elif [ $# -eq 2 ]; then        local search_term="$1"        if
                [ -d "$2" ]; then            local dir="$2"        else            echo
                "Directory $2 not found"            return        fi    else        echo
                "Usage: search_dir <search_term> [<dir>]"        return    fi    dir=$(realpath
                "$dir")    local matches=$(find "$dir" -type f ! -path ''*/.*'' -exec
                grep -nIH -- "$search_term" {} + | cut -d: -f1 | sort | uniq -c)    #
                if no matches, return    if [ -z "$matches" ]; then        echo "No
                matches found for \"$search_term\" in $dir"        return    fi    #
                Calculate total number of matches    local num_matches=$(echo "$matches"
                | awk ''{sum+=$1} END {print sum}'')    # calculate total number of
                files matched    local num_files=$(echo "$matches" | wc -l | awk ''{$1=$1;
                print $0}'')    # if num_files is > 100, print an error    if [ $num_files
                -gt 100 ]; then        echo "More than $num_files files matched for
                \"$search_term\" in $dir. Please narrow your search."        return    fi    echo
                "Found $num_matches matches for \"$search_term\" in $dir:"    echo
                "$matches" | awk ''{$2=$2; gsub(/^\.+\/+/, "./", $2); print $2 " ("$1"
                matches)"}''    echo "End of matches for \"$search_term\" in $dir"}'
              docstring: searches for search_term in all files in dir. If dir is not
                provided, searches in the current directory
              end_name: null
              name: search_dir
              signature: search_dir <search_term> [<dir>]
            - arguments:
                file:
                  description: the file to search in (if not provided, searches in
                    the current open file)
                  required: false
                  type: string
                search_term:
                  description: the term to search for
                  required: true
                  type: string
              code: 'search_file() {    # Check if the first argument is provided    if
                [ -z "$1" ]; then        echo "Usage: search_file <search_term> [<file>]"        return    fi    #
                Check if the second argument is provided    if [ -n "$2" ]; then        #
                Check if the provided argument is a valid file        if [ -f "$2"
                ]; then            local file="$2"  # Set file if valid        else            echo
                "Usage: search_file <search_term> [<file>]"            echo "Error:
                File name $2 not found. Please provide a valid file name."            return  #
                Exit if the file is not valid        fi    else        # Check if
                a file is open        if [ -z "$CURRENT_FILE" ]; then            echo
                "No file open. Use the open command first."            return  # Exit
                if no file is open        fi        local file="$CURRENT_FILE"  #
                Set file to the current open file    fi    local search_term="$1"    file=$(realpath
                "$file")    # Use grep to directly get the desired formatted output    local
                matches=$(grep -nH -- "$search_term" "$file")    # Check if no matches
                were found    if [ -z "$matches" ]; then        echo "No matches found
                for \"$search_term\" in $file"        return    fi    # Calculate
                total number of matches    local num_matches=$(echo "$matches" | wc
                -l | awk ''{$1=$1; print $0}'')    # calculate total number of lines
                matched    local num_lines=$(echo "$matches" | cut -d: -f1 | sort
                | uniq | wc -l | awk ''{$1=$1; print $0}'')    # if num_lines is >
                100, print an error    if [ $num_lines -gt 100 ]; then        echo
                "More than $num_lines lines matched for \"$search_term\" in $file.
                Please narrow your search."        return    fi    # Print the total
                number of matches and the matches themselves    echo "Found $num_matches
                matches for \"$search_term\" in $file:"    echo "$matches" | cut -d:
                -f1-2 | sort -u -t: -k2,2n | while IFS=: read -r filename line_number;
                do        echo "Line $line_number:$(sed -n "${line_number}p" "$file")"    done    echo
                "End of matches for \"$search_term\" in $file"}'
              docstring: searches for search_term in file. If file is not provided,
                searches in the current open file
              end_name: null
              name: search_file
              signature: search_file <search_term> [<file>]
            - arguments:
                dir:
                  description: the directory to search in (if not provided, searches
                    in the current directory)
                  required: false
                  type: string
                file_name:
                  description: the name of the file to search for
                  required: true
                  type: string
              code: 'find_file() {    if [ $# -eq 1 ]; then        local file_name="$1"        local
                dir="./"    elif [ $# -eq 2 ]; then        local file_name="$1"        if
                [ -d "$2" ]; then            local dir="$2"        else            echo
                "Directory $2 not found"            return        fi    else        echo
                "Usage: find_file <file_name> [<dir>]"        return    fi    dir=$(realpath
                "$dir")    local matches=$(find "$dir" -type f -name "$file_name")    #
                if no matches, return    if [ -z "$matches" ]; then        echo "No
                matches found for \"$file_name\" in $dir"        return    fi    #
                Calculate total number of matches    local num_matches=$(echo "$matches"
                | wc -l | awk ''{$1=$1; print $0}'')    echo "Found $num_matches matches
                for \"$file_name\" in $dir:"    echo "$matches" | awk ''{print $0}''}'
              docstring: finds all files with the given name in dir. If dir is not
                provided, searches in the current directory
              end_name: null
              name: find_file
              signature: find_file <file_name> [<dir>]
            - arguments:
                end_line:
                  description: the line number to end the edit at (inclusive)
                  required: true
                  type: integer
                replacement_text:
                  description: the text to replace the current selection with
                  required: true
                  type: string
                start_line:
                  description: the line number to start the edit at
                  required: true
                  type: integer
              code: 'edit() {    if [ -z "$CURRENT_FILE" ]    then        echo ''No
                file open. Use the `open` command first.''        return    fi    local
                start_line="$(echo $1: | cut -d: -f1)"    local end_line="$(echo $1:
                | cut -d: -f2)"    if [ -z "$start_line" ] || [ -z "$end_line" ]    then        echo
                "Usage: edit <start_line>:<end_line>"        return    fi    local
                re=''^[0-9]+$''    if ! [[ $start_line =~ $re ]]; then        echo
                "Usage: edit <start_line>:<end_line>"        echo "Error: start_line
                must be a number"        return    fi    if ! [[ $end_line =~ $re
                ]]; then        echo "Usage: edit <start_line>:<end_line>"        echo
                "Error: end_line must be a number"        return    fi    # Bash array
                starts at 0, so let''s adjust    local start_line=$((start_line -
                1))    local end_line=$((end_line))    local line_count=0    local
                replacement=()    while IFS= read -r line    do        replacement+=("$line")        ((line_count++))    done    #
                Create a backup of the current file    cp "$CURRENT_FILE" "/root/$(basename
                "$CURRENT_FILE")_backup"    # Read the file line by line into an array    mapfile
                -t lines < "$CURRENT_FILE"    local new_lines=("${lines[@]:0:$start_line}"
                "${replacement[@]}" "${lines[@]:$((end_line))}")    # Write the new
                stuff directly back into the original file    printf "%s\n" "${new_lines[@]}"
                >| "$CURRENT_FILE"    # Run linter    if [[ $CURRENT_FILE == *.py
                ]]; then        lint_output=$(flake8 --isolated --select=F821,F822,F831,E111,E112,E113,E999,E902
                "$CURRENT_FILE" 2>&1)    else        # do nothing        lint_output=""    fi    #
                if there is no output, then the file is good    if [ -z "$lint_output"
                ]; then        export CURRENT_LINE=$start_line        _constrain_line        _print        echo
                "File updated. Please review the changes and make sure they are correct
                (correct indentation, no duplicate lines, etc). Edit the file again
                if necessary."    else        echo "Your proposed edit has introduced
                new syntax error(s). Please read this error message carefully and
                then retry editing the file."        echo ""        echo "ERRORS:"        _split_string
                "$lint_output"        echo ""        # Save original values        original_current_line=$CURRENT_LINE        original_window=$WINDOW        #
                Update values        export CURRENT_LINE=$(( (line_count / 2) + start_line
                )) # Set to "center" of edit        export WINDOW=$((line_count +
                10)) # Show +/- 5 lines around edit        echo "This is how your
                edit would have looked if applied"        echo "-------------------------------------------------"        _constrain_line        _print        echo
                "-------------------------------------------------"        echo ""        #
                Restoring CURRENT_FILE to original contents.        cp "/root/$(basename
                "$CURRENT_FILE")_backup" "$CURRENT_FILE"        export CURRENT_LINE=$((
                ((end_line - start_line + 1) / 2) + start_line ))        export WINDOW=$((end_line
                - start_line + 10))        echo "This is the original code before
                your edit"        echo "-------------------------------------------------"        _constrain_line        _print        echo
                "-------------------------------------------------"        # Restore
                original values        export CURRENT_LINE=$original_current_line        export
                WINDOW=$original_window        echo "Your changes have NOT been applied.
                Please fix your edit command and try again."        echo "You either
                need to 1) Specify the correct start/end line arguments or 2) Correct
                your edit code."        echo "DO NOT re-run the same failed edit command.
                Running it again will lead to the same error."    fi    # Remove backup
                file    rm -f "/root/$(basename "$CURRENT_FILE")_backup"}'
              docstring: replaces lines <start_line> through <end_line> (inclusive)
                with the given text in the open file. The replacement text is terminated
                by a line with only end_of_edit on it. All of the <replacement text>
                will be entered, so make sure your indentation is formatted properly.
                Python files will be checked for syntax errors after the edit. If
                the system detects a syntax error, the edit will not be executed.
                Simply try to edit the file again, but make sure to read the error
                message and modify the edit command you issue accordingly. Issuing
                the same command a second time will just lead to the same error message
                again.
              end_name: end_of_edit
              name: edit
              signature: |-
                edit <start_line>:<end_line>
                <replacement_text>
                end_of_edit
            _subroutines: {}
            blocklist:
            - vim
            - vi
            - emacs
            - nano
            - nohup
            - git
            blocklist_error_template: Interactive operation '{name}' is not supported
              by this environment
            blocklist_standalone:
            - python
            - python3
            - ipython
            - bash
            - sh
            - exit
            - /bin/bash
            - /bin/sh
            - nohup
            - vi
            - vim
            - emacs
            - nano
            command_docs: |+
              open:
                docstring: opens the file at the given path in the editor. If line_number is provided, the window will be move to include that line
                signature: open <path> [<line_number>]
                arguments:
                  - path (string) [required]: the path to the file to open
                  - line_number (integer) [optional]: the line number to move the window to (if not provided, the window will start at the top of the file)

              goto:
                docstring: moves the window to show <line_number>
                signature: goto <line_number>
                arguments:
                  - line_number (integer) [required]: the line number to move the window to

              scroll_down:
                docstring: moves the window down {WINDOW} lines
                signature: scroll_down

              scroll_up:
                docstring: moves the window down {WINDOW} lines
                signature: scroll_up

              create:
                docstring: creates and opens a new file with the given name
                signature: create <filename>
                arguments:
                  - filename (string) [required]: the name of the file to create

              search_dir:
                docstring: searches for search_term in all files in dir. If dir is not provided, searches in the current directory
                signature: search_dir <search_term> [<dir>]
                arguments:
                  - search_term (string) [required]: the term to search for
                  - dir (string) [optional]: the directory to search in (if not provided, searches in the current directory)

              search_file:
                docstring: searches for search_term in file. If file is not provided, searches in the current open file
                signature: search_file <search_term> [<file>]
                arguments:
                  - search_term (string) [required]: the term to search for
                  - file (string) [optional]: the file to search in (if not provided, searches in the current open file)

              find_file:
                docstring: finds all files with the given name in dir. If dir is not provided, searches in the current directory
                signature: find_file <file_name> [<dir>]
                arguments:
                  - file_name (string) [required]: the name of the file to search for
                  - dir (string) [optional]: the directory to search in (if not provided, searches in the current directory)

              edit:
                docstring: replaces lines <start_line> through <end_line> (inclusive) with the given text in the open file. The replacement text is terminated by a line with only end_of_edit on it. All of the <replacement text> will be entered, so make sure your indentation is formatted properly. Python files will be checked for syntax errors after the edit. If the system detects a syntax error, the edit will not be executed. Simply try to edit the file again, but make sure to read the error message and modify the edit command you issue accordingly. Issuing the same command a second time will just lead to the same error message again.
                signature: edit <start_line>:<end_line>
              <replacement_text>
              end_of_edit
                arguments:
                  - start_line (integer) [required]: the line number to start the edit at
                  - end_line (integer) [required]: the line number to end the edit at (inclusive)
                  - replacement_text (string) [required]: the text to replace the current selection with

            command_files:
            - /home/minkim/swe/testgen/swe_proj2/config/commands/defaults.sh
            - /home/minkim/swe/testgen/swe_proj2/config/commands/search.sh
            - /home/minkim/swe/testgen/swe_proj2/config/commands/edit_linting.sh
            - /home/minkim/swe/testgen/swe_proj2/config/commands/_split_string.py
            demonstration_template: |
              Here is a demonstration of how to correctly accomplish this task.
              It is included to show you how to correctly use the interface.
              You do not need to follow exactly what is done in the demonstration.
              --- DEMONSTRATION ---
              {demonstration}
              --- END OF DEMONSTRATION ---
            demonstrations: []
            env_variables:
              CURRENT_FILE: ''
              CURRENT_LINE: '0'
              OVERLAP: '2'
              SEARCH_FILES: ()
              SEARCH_INDEX: '0'
              SEARCH_RESULTS: ()
              WINDOW: '100'
            format_error_template: |
              Your output was not formatted correctly. You must always include one discussion and one command as part of your response. Make sure you do not have multiple discussion/command tags.
              Please make sure your output precisely matches the following format:
              DISCUSSION
              Discuss here with yourself about what your planning and what you're going to do in this step.

              ```
              command(s) that you're going to run
              ```
            history_processor: {}
            history_processor_args:
              n: 5
            instance_template: "We're currently solving the following issue within\
              \ our repository. Here's the issue text:\nISSUE:\n{issue}\n\nINSTRUCTIONS:\n\
              Now, you're going to solve this issue on your own. Your terminal session\
              \ has started and you're in the repository's root directory. You can\
              \ use any bash commands or the special interface to help you. Edit all\
              \ the files you need to and run any checks or tests that you want.\n\
              Remember, YOU CAN ONLY ENTER ONE COMMAND AT A TIME. You should always\
              \ wait for feedback after every command.\nWhen you're satisfied with\
              \ all of the changes you've made, you can submit your changes to the\
              \ code base by simply running the submit command.\nNote however that\
              \ you cannot use any interactive session commands (e.g. python, vim)\
              \ in this environment, but you can write scripts and run them. E.g.\
              \ you can write a python script and then run it with `python <script_name>.py`.\n\
              \nNOTE ABOUT THE EDIT COMMAND: Indentation really matters! When editing\
              \ a file, make sure to insert appropriate indentation before each line!\n\
              \n\nIMPORTANT TIPS:\n1. Always start by trying to replicate the bug\
              \ that the issues discusses.\n  If the issue includes code for reproducing\
              \ the bug, we recommend that you re-implement that in your environment,\
              \ and run it to make sure you can reproduce the bug.\n  Then start trying\
              \ to fix it.\n  When you think you've fixed the bug, re-run the bug\
              \ reproduction script to make sure that the bug has indeed been fixed.\n\
              \n\n2. If you run a command and it doesn't work, try running a different\
              \ command. A command that did not work once will not work the second\
              \ time unless you modify it!\n\n3. If you open a file and need to get\
              \ to an area around a specific line that is not in the first 100 lines,\
              \ say line 583, don't just use the scroll_down command multiple times.\
              \ Instead, use the goto 583 command. It's much quicker.\n\n4. If the\
              \ bug reproduction script requires inputting/reading a specific file,\
              \ such as buggy-input.png, and you'd like to understand how to input\
              \ that file, conduct a search in the existing repo code, to see whether\
              \ someone else has already done that. Do this by running the command:\
              \ find_file \"buggy-input.png\" If that doesn't work, use the linux\
              \ 'find' command.\n\n5. Always make sure to look at the currently open\
              \ file and the current working directory (which appears right after\
              \ the currently open file). The currently open file might be in a different\
              \ directory than the working directory! Note that some commands, such\
              \ as 'create', open files, so they might change the current  open file.\n\
              \n6. When editing files, it is easy to accidentally specify a wrong\
              \ line number or to write code with incorrect indentation. Always check\
              \ the code after you issue an edit to make sure that it reflects what\
              \ you wanted to accomplish. If it didn't, issue another command to fix\
              \ it.\n\n7. Only return \"succeed\" command when the current task is\
              \ truly completed. If the current task still cannot be completed after\
              \ trying many different solutions, please return \"fail\" command. The\
              \ final output format is as follows:    "
            multi_roles_transfer_template: |
              You are currently in a team organized by a manager, where each role has its own tasks. Everyone is working together to solve this issue. Here is some information about the team.
              {history_conclusion}

              CURRENT STATE
              (Open file: {open_file})
              (Current directory: {working_dir})
              bash-$
            next_step_no_output_template: |-
              Your command ran successfully and did not produce any output.
              (Open file: {open_file})
              (Current directory: {working_dir})
              bash-$
            next_step_template: |-
              {observation}
              (Open file: {open_file})
              (Current directory: {working_dir})
              bash-$
            parse_command: {}
            parse_function: {}
            planer_command:
              arguments: null
              code: null
              docstring: null
              end_name: end_of_plan
              name: plan
              signature: null
            put_demos_in_history: false
            state_command:
              arguments: null
              code: |
                state() {
                  local working_dir="$PWD";
                  if [ -z $CURRENT_FILE ]; then
                      echo '{"open_file": "n/a", "working_dir": "'$working_dir'"}';
                  else
                      echo '{"open_file": "'$(realpath $CURRENT_FILE)'", "working_dir": "'$working_dir'"}';
                  fi
                };
              docstring: null
              end_name: null
              name: state
              signature: null
            strategy_template: null
            submit_command: submit
            subroutine_types: []
            system_template: "SETTING: You are a helpful assistant tasked with writing\
              \ tests to reproduce a specified issue, and you're working directly\
              \ in the command line with a special interface.\n\nThe special interface\
              \ consists of a file editor that shows you {WINDOW} lines of a file\
              \ at a time.\nIn addition to typical bash commands, you can also use\
              \ the following commands to help you navigate and edit files.\n\nCOMMANDS:\n\
              {command_docs}\n\nPlease note that THE EDIT COMMAND REQUIRES PROPER\
              \ INDENTATION. \nIf you'd like to add the line '        print(x)' you\
              \ must fully write that out, with all those spaces before the code!\
              \ Indentation is important and code that is not indented correctly will\
              \ fail and require fixing before it can be run.\n\nRESPONSE FORMAT:\n\
              Your shell prompt is formatted as follows:\n(Open file: <path>) <cwd>\
              \ $\n\nYou need to format your output using two fields; discussion and\
              \ command.\nYour output should always include _one_ discussion and _one_\
              \ command field EXACTLY as in the following example:\nDISCUSSION\nFirst\
              \ I'll start by using ls to see what files are in the current directory.\
              \ Then maybe we can look at some relevant files to see what they look\
              \ like.\n```\nls -a\n```\n\nYou should only include a *SINGLE* command\
              \ in the command section and then wait for a response from the shell\
              \ before continuing with more discussion and commands. Everything you\
              \ include in the DISCUSSION section will be saved for future reference.\n\
              If you'd like to issue two commands at once, PLEASE DO NOT DO THAT!\
              \ Please instead first submit just the first command, and then after\
              \ receiving a response you'll be able to issue the second command. \n\
              You're free to use any other bash commands you want (e.g. find, grep,\
              \ cat, ls, cd) in addition to the special commands listed above.\nHowever,\
              \ the environment does NOT support interactive session commands (e.g.\
              \ vi, vim), so please do not invoke them.\n\nOnce you make *NO PROGRESS*\
              \ on current task, you should stop generating next action. Instead,\
              \ if current task is succeeded, you should output `succeed`. If failed,\
              \ you should output `fail`.\nRESPONSE FORMAT:\nYour output should always\
              \ contains a SUMMARY OF ALL ACTIONS PERFORMED and the TASK STATUS (`succeed`\
              \ or `fail`). \nDISCUSSION\nThrough the analysis of the issue and the\
              \ search within the project, the issue has been reproduced in the `reproduce.py`\
              \ file.\n```\nsucceed\n```\n\nIMPORTANT TIPS: your job is reproduce\
              \ the bug described in the issue USING A NEWLY CREATED FILE NAMED `reproduce.py`.\
              \ DO NOT EDIT THE CODE IN THE REPOSITORY!!!"
            util_functions:
            - arguments: null
              code: '_print() {    local total_lines=$(awk ''END {print NR}'' $CURRENT_FILE)    echo
                "[File: $(realpath $CURRENT_FILE) ($total_lines lines total)]"    lines_above=$(jq
                -n "$CURRENT_LINE - $WINDOW/2" | jq ''[0, .] | max | floor'')    lines_below=$(jq
                -n "$total_lines - $CURRENT_LINE - $WINDOW/2" | jq ''[0, .] | max
                | round'')    if [ $lines_above -gt 0 ]; then        echo "($lines_above
                more lines above)"    fi    cat $CURRENT_FILE | grep -n $ | head -n
                $(jq -n "[$CURRENT_LINE + $WINDOW/2, $WINDOW/2] | max | floor") |
                tail -n $(jq -n "$WINDOW")    if [ $lines_below -gt 0 ]; then        echo
                "($lines_below more lines below)"    fi}'
              docstring: null
              end_name: null
              name: _print
              signature: _print
            - arguments: null
              code: _constrain_line() {    if [ -z "$CURRENT_FILE" ]    then        echo
                "No file open. Use the open command first."        return    fi    local
                max_line=$(awk 'END {print NR}' $CURRENT_FILE)    local half_window=$(jq
                -n "$WINDOW/2" | jq 'floor')    export CURRENT_LINE=$(jq -n "[$CURRENT_LINE,
                $max_line - $half_window] | min")    export CURRENT_LINE=$(jq -n "[$CURRENT_LINE,
                $half_window] | max")}
              docstring: null
              end_name: null
              name: _constrain_line
              signature: _constrain_line
          config_file: config/configs/roles/reproducer.yaml
          model:
            host_url: localhost:11434
            model_name: azure:gpt-4o-2024-05-13
            per_instance_cost_limit: 0.0
            replay_path: null
            temperature: 1.0
            top_p: 1.0
            total_cost_limit: 0.0
        agent_file: config/configs/roles/reproducer.yaml
        docstring: null
        end_name: null
        init_observation: null
        model:
          host_url: localhost:11434
          model_name: azure:gpt-4o-2024-05-13
          per_instance_cost_limit: 0.0
          replay_path: null
          temperature: 1.0
          top_p: 1.0
          total_cost_limit: 0.0
        name: Reproducer
        return_type: traj
        signature: null
      Tester:
        agent_args:
          config:
            _commands:
            - arguments:
                line_number:
                  description: the line number to move the window to (if not provided,
                    the window will start at the top of the file)
                  required: false
                  type: integer
                path:
                  description: the path to the file to open
                  required: true
                  type: string
              code: 'open() {    if [ -z "$1" ]    then        echo "Usage: open <file>"        return    fi    #
                Check if the second argument is provided    if [ -n "$2" ]; then        #
                Check if the provided argument is a valid number        if ! [[ $2
                =~ ^[0-9]+$ ]]; then            echo "Usage: open <file> [<line_number>]"            echo
                "Error: <line_number> must be a number"            return  # Exit
                if the line number is not valid        fi        local max_line=$(awk
                ''END {print NR}'' $1)        if [ $2 -gt $max_line ]; then            echo
                "Warning: <line_number> ($2) is greater than the number of lines in
                the file ($max_line)"            echo "Warning: Setting <line_number>
                to $max_line"            local line_number=$(jq -n "$max_line")  #
                Set line number to max if greater than max        elif [ $2 -lt 1
                ]; then            echo "Warning: <line_number> ($2) is less than
                1"            echo "Warning: Setting <line_number> to 1"            local
                line_number=$(jq -n "1")  # Set line number to 1 if less than 1        else            local
                OFFSET=$(jq -n "$WINDOW/6" | jq ''floor'')            local line_number=$(jq
                -n "[$2 + $WINDOW/2 - $OFFSET, 1] | max | floor")        fi    else        local
                line_number=$(jq -n "$WINDOW/2")  # Set default line number if not
                provided    fi    if [ -f "$1" ]; then        export CURRENT_FILE=$(realpath
                $1)        export CURRENT_LINE=$line_number        _constrain_line        _print    elif
                [ -d "$1" ]; then        echo "Error: $1 is a directory. You can only
                open files. Use cd or ls to navigate directories."    else        echo
                "File $1 not found"    fi}'
              docstring: opens the file at the given path in the editor. If line_number
                is provided, the window will be move to include that line
              end_name: null
              name: open
              signature: open <path> [<line_number>]
            - arguments:
                line_number:
                  description: the line number to move the window to
                  required: true
                  type: integer
              code: 'goto() {    if [ $# -gt 1 ]; then        echo "goto allows only
                one line number at a time."        return    fi    if [ -z "$CURRENT_FILE"
                ]    then        echo "No file open. Use the open command first."        return    fi    if
                [ -z "$1" ]    then        echo "Usage: goto <line>"        return    fi    if
                ! [[ $1 =~ ^[0-9]+$ ]]    then        echo "Usage: goto <line>"        echo
                "Error: <line> must be a number"        return    fi    local max_line=$(awk
                ''END {print NR}'' $CURRENT_FILE)    if [ $1 -gt $max_line ]    then        echo
                "Error: <line> must be less than or equal to $max_line"        return    fi    local
                OFFSET=$(jq -n "$WINDOW/6" | jq ''floor'')    export CURRENT_LINE=$(jq
                -n "[$1 + $WINDOW/2 - $OFFSET, 1] | max | floor")    _constrain_line    _print}'
              docstring: moves the window to show <line_number>
              end_name: null
              name: goto
              signature: goto <line_number>
            - arguments: null
              code: scroll_down() {    if [ -z "$CURRENT_FILE" ]    then        echo
                "No file open. Use the open command first."        return    fi    export
                CURRENT_LINE=$(jq -n "$CURRENT_LINE + $WINDOW - $OVERLAP")    _constrain_line    _print}
              docstring: moves the window down {WINDOW} lines
              end_name: null
              name: scroll_down
              signature: scroll_down
            - arguments: null
              code: scroll_up() {    if [ -z "$CURRENT_FILE" ]    then        echo
                "No file open. Use the open command first."        return    fi    export
                CURRENT_LINE=$(jq -n "$CURRENT_LINE - $WINDOW + $OVERLAP")    _constrain_line    _print}
              docstring: moves the window down {WINDOW} lines
              end_name: null
              name: scroll_up
              signature: scroll_up
            - arguments:
                filename:
                  description: the name of the file to create
                  required: true
                  type: string
              code: "create() {    if [ -z \"$1\" ]; then        echo \"Usage: create\
                \ <filename>\"        return    fi    # Check if the file already\
                \ exists    if [ -e \"$1\" ]; then        echo \"Error: File '$1'\
                \ already exists.\"\t\topen \"$1\"        return    fi    # Create\
                \ the file an empty new line    printf \"\\n\" > \"$1\"    # Use the\
                \ existing open command to open the created file    open \"$1\"}"
              docstring: creates and opens a new file with the given name
              end_name: null
              name: create
              signature: create <filename>
            - arguments:
                dir:
                  description: the directory to search in (if not provided, searches
                    in the current directory)
                  required: false
                  type: string
                search_term:
                  description: the term to search for
                  required: true
                  type: string
              code: 'search_dir() {    if [ $# -eq 1 ]; then        local search_term="$1"        local
                dir="./"    elif [ $# -eq 2 ]; then        local search_term="$1"        if
                [ -d "$2" ]; then            local dir="$2"        else            echo
                "Directory $2 not found"            return        fi    else        echo
                "Usage: search_dir <search_term> [<dir>]"        return    fi    dir=$(realpath
                "$dir")    local matches=$(find "$dir" -type f ! -path ''*/.*'' -exec
                grep -nIH -- "$search_term" {} + | cut -d: -f1 | sort | uniq -c)    #
                if no matches, return    if [ -z "$matches" ]; then        echo "No
                matches found for \"$search_term\" in $dir"        return    fi    #
                Calculate total number of matches    local num_matches=$(echo "$matches"
                | awk ''{sum+=$1} END {print sum}'')    # calculate total number of
                files matched    local num_files=$(echo "$matches" | wc -l | awk ''{$1=$1;
                print $0}'')    # if num_files is > 100, print an error    if [ $num_files
                -gt 100 ]; then        echo "More than $num_files files matched for
                \"$search_term\" in $dir. Please narrow your search."        return    fi    echo
                "Found $num_matches matches for \"$search_term\" in $dir:"    echo
                "$matches" | awk ''{$2=$2; gsub(/^\.+\/+/, "./", $2); print $2 " ("$1"
                matches)"}''    echo "End of matches for \"$search_term\" in $dir"}'
              docstring: searches for search_term in all files in dir. If dir is not
                provided, searches in the current directory
              end_name: null
              name: search_dir
              signature: search_dir <search_term> [<dir>]
            - arguments:
                file:
                  description: the file to search in (if not provided, searches in
                    the current open file)
                  required: false
                  type: string
                search_term:
                  description: the term to search for
                  required: true
                  type: string
              code: 'search_file() {    # Check if the first argument is provided    if
                [ -z "$1" ]; then        echo "Usage: search_file <search_term> [<file>]"        return    fi    #
                Check if the second argument is provided    if [ -n "$2" ]; then        #
                Check if the provided argument is a valid file        if [ -f "$2"
                ]; then            local file="$2"  # Set file if valid        else            echo
                "Usage: search_file <search_term> [<file>]"            echo "Error:
                File name $2 not found. Please provide a valid file name."            return  #
                Exit if the file is not valid        fi    else        # Check if
                a file is open        if [ -z "$CURRENT_FILE" ]; then            echo
                "No file open. Use the open command first."            return  # Exit
                if no file is open        fi        local file="$CURRENT_FILE"  #
                Set file to the current open file    fi    local search_term="$1"    file=$(realpath
                "$file")    # Use grep to directly get the desired formatted output    local
                matches=$(grep -nH -- "$search_term" "$file")    # Check if no matches
                were found    if [ -z "$matches" ]; then        echo "No matches found
                for \"$search_term\" in $file"        return    fi    # Calculate
                total number of matches    local num_matches=$(echo "$matches" | wc
                -l | awk ''{$1=$1; print $0}'')    # calculate total number of lines
                matched    local num_lines=$(echo "$matches" | cut -d: -f1 | sort
                | uniq | wc -l | awk ''{$1=$1; print $0}'')    # if num_lines is >
                100, print an error    if [ $num_lines -gt 100 ]; then        echo
                "More than $num_lines lines matched for \"$search_term\" in $file.
                Please narrow your search."        return    fi    # Print the total
                number of matches and the matches themselves    echo "Found $num_matches
                matches for \"$search_term\" in $file:"    echo "$matches" | cut -d:
                -f1-2 | sort -u -t: -k2,2n | while IFS=: read -r filename line_number;
                do        echo "Line $line_number:$(sed -n "${line_number}p" "$file")"    done    echo
                "End of matches for \"$search_term\" in $file"}'
              docstring: searches for search_term in file. If file is not provided,
                searches in the current open file
              end_name: null
              name: search_file
              signature: search_file <search_term> [<file>]
            - arguments:
                dir:
                  description: the directory to search in (if not provided, searches
                    in the current directory)
                  required: false
                  type: string
                file_name:
                  description: the name of the file to search for
                  required: true
                  type: string
              code: 'find_file() {    if [ $# -eq 1 ]; then        local file_name="$1"        local
                dir="./"    elif [ $# -eq 2 ]; then        local file_name="$1"        if
                [ -d "$2" ]; then            local dir="$2"        else            echo
                "Directory $2 not found"            return        fi    else        echo
                "Usage: find_file <file_name> [<dir>]"        return    fi    dir=$(realpath
                "$dir")    local matches=$(find "$dir" -type f -name "$file_name")    #
                if no matches, return    if [ -z "$matches" ]; then        echo "No
                matches found for \"$file_name\" in $dir"        return    fi    #
                Calculate total number of matches    local num_matches=$(echo "$matches"
                | wc -l | awk ''{$1=$1; print $0}'')    echo "Found $num_matches matches
                for \"$file_name\" in $dir:"    echo "$matches" | awk ''{print $0}''}'
              docstring: finds all files with the given name in dir. If dir is not
                provided, searches in the current directory
              end_name: null
              name: find_file
              signature: find_file <file_name> [<dir>]
            - arguments:
                end_line:
                  description: the line number to end the edit at (inclusive)
                  required: true
                  type: integer
                replacement_text:
                  description: the text to replace the current selection with
                  required: true
                  type: string
                start_line:
                  description: the line number to start the edit at
                  required: true
                  type: integer
              code: 'edit() {    if [ -z "$CURRENT_FILE" ]    then        echo ''No
                file open. Use the `open` command first.''        return    fi    local
                start_line="$(echo $1: | cut -d: -f1)"    local end_line="$(echo $1:
                | cut -d: -f2)"    if [ -z "$start_line" ] || [ -z "$end_line" ]    then        echo
                "Usage: edit <start_line>:<end_line>"        return    fi    local
                re=''^[0-9]+$''    if ! [[ $start_line =~ $re ]]; then        echo
                "Usage: edit <start_line>:<end_line>"        echo "Error: start_line
                must be a number"        return    fi    if ! [[ $end_line =~ $re
                ]]; then        echo "Usage: edit <start_line>:<end_line>"        echo
                "Error: end_line must be a number"        return    fi    # Bash array
                starts at 0, so let''s adjust    local start_line=$((start_line -
                1))    local end_line=$((end_line))    local line_count=0    local
                replacement=()    while IFS= read -r line    do        replacement+=("$line")        ((line_count++))    done    #
                Create a backup of the current file    cp "$CURRENT_FILE" "/root/$(basename
                "$CURRENT_FILE")_backup"    # Read the file line by line into an array    mapfile
                -t lines < "$CURRENT_FILE"    local new_lines=("${lines[@]:0:$start_line}"
                "${replacement[@]}" "${lines[@]:$((end_line))}")    # Write the new
                stuff directly back into the original file    printf "%s\n" "${new_lines[@]}"
                >| "$CURRENT_FILE"    # Run linter    if [[ $CURRENT_FILE == *.py
                ]]; then        lint_output=$(flake8 --isolated --select=F821,F822,F831,E111,E112,E113,E999,E902
                "$CURRENT_FILE" 2>&1)    else        # do nothing        lint_output=""    fi    #
                if there is no output, then the file is good    if [ -z "$lint_output"
                ]; then        export CURRENT_LINE=$start_line        _constrain_line        _print        echo
                "File updated. Please review the changes and make sure they are correct
                (correct indentation, no duplicate lines, etc). Edit the file again
                if necessary."    else        echo "Your proposed edit has introduced
                new syntax error(s). Please read this error message carefully and
                then retry editing the file."        echo ""        echo "ERRORS:"        _split_string
                "$lint_output"        echo ""        # Save original values        original_current_line=$CURRENT_LINE        original_window=$WINDOW        #
                Update values        export CURRENT_LINE=$(( (line_count / 2) + start_line
                )) # Set to "center" of edit        export WINDOW=$((line_count +
                10)) # Show +/- 5 lines around edit        echo "This is how your
                edit would have looked if applied"        echo "-------------------------------------------------"        _constrain_line        _print        echo
                "-------------------------------------------------"        echo ""        #
                Restoring CURRENT_FILE to original contents.        cp "/root/$(basename
                "$CURRENT_FILE")_backup" "$CURRENT_FILE"        export CURRENT_LINE=$((
                ((end_line - start_line + 1) / 2) + start_line ))        export WINDOW=$((end_line
                - start_line + 10))        echo "This is the original code before
                your edit"        echo "-------------------------------------------------"        _constrain_line        _print        echo
                "-------------------------------------------------"        # Restore
                original values        export CURRENT_LINE=$original_current_line        export
                WINDOW=$original_window        echo "Your changes have NOT been applied.
                Please fix your edit command and try again."        echo "You either
                need to 1) Specify the correct start/end line arguments or 2) Correct
                your edit code."        echo "DO NOT re-run the same failed edit command.
                Running it again will lead to the same error."    fi    # Remove backup
                file    rm -f "/root/$(basename "$CURRENT_FILE")_backup"}'
              docstring: replaces lines <start_line> through <end_line> (inclusive)
                with the given text in the open file. The replacement text is terminated
                by a line with only end_of_edit on it. All of the <replacement text>
                will be entered, so make sure your indentation is formatted properly.
                Python files will be checked for syntax errors after the edit. If
                the system detects a syntax error, the edit will not be executed.
                Simply try to edit the file again, but make sure to read the error
                message and modify the edit command you issue accordingly. Issuing
                the same command a second time will just lead to the same error message
                again.
              end_name: end_of_edit
              name: edit
              signature: |-
                edit <start_line>:<end_line>
                <replacement_text>
                end_of_edit
            _subroutines: {}
            blocklist:
            - vim
            - vi
            - emacs
            - nano
            - nohup
            - git
            blocklist_error_template: Interactive operation '{name}' is not supported
              by this environment
            blocklist_standalone:
            - python
            - python3
            - ipython
            - bash
            - sh
            - exit
            - /bin/bash
            - /bin/sh
            - nohup
            - vi
            - vim
            - emacs
            - nano
            command_docs: |+
              open:
                docstring: opens the file at the given path in the editor. If line_number is provided, the window will be move to include that line
                signature: open <path> [<line_number>]
                arguments:
                  - path (string) [required]: the path to the file to open
                  - line_number (integer) [optional]: the line number to move the window to (if not provided, the window will start at the top of the file)

              goto:
                docstring: moves the window to show <line_number>
                signature: goto <line_number>
                arguments:
                  - line_number (integer) [required]: the line number to move the window to

              scroll_down:
                docstring: moves the window down {WINDOW} lines
                signature: scroll_down

              scroll_up:
                docstring: moves the window down {WINDOW} lines
                signature: scroll_up

              create:
                docstring: creates and opens a new file with the given name
                signature: create <filename>
                arguments:
                  - filename (string) [required]: the name of the file to create

              search_dir:
                docstring: searches for search_term in all files in dir. If dir is not provided, searches in the current directory
                signature: search_dir <search_term> [<dir>]
                arguments:
                  - search_term (string) [required]: the term to search for
                  - dir (string) [optional]: the directory to search in (if not provided, searches in the current directory)

              search_file:
                docstring: searches for search_term in file. If file is not provided, searches in the current open file
                signature: search_file <search_term> [<file>]
                arguments:
                  - search_term (string) [required]: the term to search for
                  - file (string) [optional]: the file to search in (if not provided, searches in the current open file)

              find_file:
                docstring: finds all files with the given name in dir. If dir is not provided, searches in the current directory
                signature: find_file <file_name> [<dir>]
                arguments:
                  - file_name (string) [required]: the name of the file to search for
                  - dir (string) [optional]: the directory to search in (if not provided, searches in the current directory)

              edit:
                docstring: replaces lines <start_line> through <end_line> (inclusive) with the given text in the open file. The replacement text is terminated by a line with only end_of_edit on it. All of the <replacement text> will be entered, so make sure your indentation is formatted properly. Python files will be checked for syntax errors after the edit. If the system detects a syntax error, the edit will not be executed. Simply try to edit the file again, but make sure to read the error message and modify the edit command you issue accordingly. Issuing the same command a second time will just lead to the same error message again.
                signature: edit <start_line>:<end_line>
              <replacement_text>
              end_of_edit
                arguments:
                  - start_line (integer) [required]: the line number to start the edit at
                  - end_line (integer) [required]: the line number to end the edit at (inclusive)
                  - replacement_text (string) [required]: the text to replace the current selection with

            command_files:
            - /home/minkim/swe/testgen/swe_proj2/config/commands/defaults.sh
            - /home/minkim/swe/testgen/swe_proj2/config/commands/search.sh
            - /home/minkim/swe/testgen/swe_proj2/config/commands/edit_linting.sh
            - /home/minkim/swe/testgen/swe_proj2/config/commands/_split_string.py
            demonstration_template: |
              Here is a demonstration of how to correctly accomplish this task.
              It is included to show you how to correctly use the interface.
              You do not need to follow exactly what is done in the demonstration.
              --- DEMONSTRATION ---
              {demonstration}
              --- END OF DEMONSTRATION ---
            demonstrations: []
            env_variables:
              CURRENT_FILE: ''
              CURRENT_LINE: '0'
              OVERLAP: '2'
              SEARCH_FILES: ()
              SEARCH_INDEX: '0'
              SEARCH_RESULTS: ()
              WINDOW: '100'
            format_error_template: |
              Your output was not formatted correctly. You must always include one discussion and one command as part of your response. Make sure you do not have multiple discussion/command tags.
              Please make sure your output precisely matches the following format:
              DISCUSSION
              Discuss here with yourself about what your planning and what you're going to do in this step.

              ```
              command(s) that you're going to run
              ```
            history_processor: {}
            history_processor_args:
              n: 5
            instance_template: "We're currently solving the following issue within\
              \ our repository. Here's the issue text:\nISSUE:\n{issue}\n\nINSTRUCTIONS:\n\
              Now, you're going to solve this issue on your own from the perspective\
              \ of a tester. Your terminal session has started and you're in the repository's\
              \ root directory. You can use any bash commands or the special interface\
              \ to help you. \nRemember, YOU CAN ONLY ENTER ONE COMMAND AT A TIME.\
              \ You should always wait for feedback after every command.\n\nIMPORTANT\
              \ TIPS:\n1. Besides general commands, programmers also have special\
              \ commands at their disposal. Carefully consider and select the appropriate\
              \ command to use;\n\n2. Based on your attempts to reproduce and solve\
              \ the issue, it is necessary to run <reproduce.py>.\n  \n3. When you\
              \ execute the edit command multiple times to modify the same file and\
              \ encounter syntax errors, such as indentation issues, you should consider\
              \ opening the file to review its content again, and then make modifications\
              \ based on your previous analysis.\n  \n4. If you are uncertain about\
              \ the specific line number when searching for a snippet of code, a class,\
              \ or a method within a file, prioritize using the `grep -nr <code/class/method>`\
              \ command to retrieve the approximate location. Then, after opening\
              \ the file, use the `goto` command to navigate to the snippet, preventing\
              \ excessive use of the `scroll down` command. If the `grep -nr` command\
              \ does not retrieve any relevant content, consider using the `scroll\
              \ down` or `scroll up` commands to search for the code after opening\
              \ the file.\n  \n5. If you run a command and it doesn't work, try running\
              \ a different command. A command that did not work once will not work\
              \ the second time unless you modify it!\n\n6. If you open a file and\
              \ need to get to an area around a specific line that is not in the first\
              \ 100 lines, say line 583, don't just use the scroll_down command multiple\
              \ times. Instead, use the goto 583 command. It's much quicker. \n  \
              \   \n7. Always make sure to look at the currently open file and the\
              \ current working directory (which appears right after the currently\
              \ open file). The currently open file might be in a different directory\
              \ than the working directory! Note that some commands, such as 'create',\
              \ open files, so they might change the current  open file.\n\n8. When\
              \ editing files, it is easy to accidentally specify a wrong line number\
              \ or to write code with incorrect indentation. Always check the code\
              \ after you issue an edit to make sure that it reflects what you wanted\
              \ to accomplish. If it didn't, issue another command to fix it.\n  \n\
              9. You can directly execute the <reproduce.py> file using `python` to\
              \ check whether the issue has been resolved.\n  \n10. Only return \"\
              succeed\" command when the current issue is truly resolved. If the current\
              \ task still cannot be completed after trying many different solutions,\
              \ please return \"fail\" command."
            multi_roles_transfer_template: |
              You are currently in a team organized by a manager, where each role has its own tasks. Everyone is working together to solve this issue. Here is some information about the team.
              {observation}

              CURRENT STATE
              (Open file: {open_file})
              (Current directory: {working_dir})
              bash-$
            next_step_no_output_template: |-
              Your command ran successfully and did not produce any output.
              (Open file: {open_file})
              (Current directory: {working_dir})
              bash-$
            next_step_template: |-
              {observation}
              (Open file: {open_file})
              (Current directory: {working_dir})
              bash-$
            parse_command: {}
            parse_function: {}
            planer_command:
              arguments: null
              code: null
              docstring: null
              end_name: end_of_plan
              name: plan
              signature: null
            put_demos_in_history: false
            state_command:
              arguments: null
              code: |
                state() {
                  local working_dir="$PWD";
                  if [ -z $CURRENT_FILE ]; then
                      echo '{"open_file": "n/a", "working_dir": "'$working_dir'"}';
                  else
                      echo '{"open_file": "'$(realpath $CURRENT_FILE)'", "working_dir": "'$working_dir'"}';
                  fi
                };
              docstring: null
              end_name: null
              name: state
              signature: null
            strategy_template: null
            submit_command: submit
            subroutine_types: []
            system_template: "You are an autonomous tester working directly in the\
              \ command line with a special interface designed for efficient and effective\
              \ software testing.\n\nIn addition to typical bash commands, you can\
              \ also use the following *general* and *tester-specific*  commands to\
              \ help you run test cases.\n\nCOMMANDS:\n{command_docs}\n\nPlease note\
              \ that THE EDIT COMMAND REQUIRES PROPER INDENTATION. \nIf you'd like\
              \ to add the line '        print(x)' you must fully write that out,\
              \ with all those spaces before the code! Indentation is important and\
              \ code that is not indented correctly will fail and require fixing before\
              \ it can be run.\n\nRESPONSE FORMAT:\nYour shell prompt is formatted\
              \ as follows:\n(Open file: <path>) <cwd> $\n\nYou need to format your\
              \ output using one field: command.\nYour output should always include\
              \ *one* command field EXACTLY as in the following example:\nFirst I'll\
              \ start by using ls to see what files are in the current directory.\
              \ Then maybe we can look at some relevant files to see what they look\
              \ like.\n```\nls -a\n```\n\nYou should only include a *SINGLE* command\
              \ in the command section and then wait for a response from the shell\
              \ before continuing with more discussion and commands.\nIf you'd like\
              \ to issue two commands at once, PLEASE DO NOT DO THAT! Please instead\
              \ first submit just the first command, and then after receiving a response\
              \ you'll be able to issue the second command.\nYou're free to use any\
              \ other bash commands you want (e.g. find, grep, cat, ls, cd) in addition\
              \ to the special commands listed above.\nHowever, the environment does\
              \ NOT support interactive session commands (e.g. python, vim), so please\
              \ do not invoke them.\n\nOnce you make *NO PROGRESS* on current task,\
              \ you should stop generating next action. Instead, if current task is\
              \ succeeded, you should output `succeed`. If failed, you should output\
              \ `fail`.\nRESPONSE FORMAT:\nYour output should always contains a SUMMARY\
              \ OF ALL ACTIONS PERFORMED and the TASK STATUS (`succeed` or `fail`).\
              \ \nDISCUSSION\nThrough the analysis of the issue and the search within\
              \ the project, the issue has been reproduced in the <path/to.py> file.\n\
              ```\nsucceed\n```\n\nIMPORTANT TIPS: your job is to verify the test\
              \ `reproduce.py` does not incur any errors."
            util_functions:
            - arguments: null
              code: '_print() {    local total_lines=$(awk ''END {print NR}'' $CURRENT_FILE)    echo
                "[File: $(realpath $CURRENT_FILE) ($total_lines lines total)]"    lines_above=$(jq
                -n "$CURRENT_LINE - $WINDOW/2" | jq ''[0, .] | max | floor'')    lines_below=$(jq
                -n "$total_lines - $CURRENT_LINE - $WINDOW/2" | jq ''[0, .] | max
                | round'')    if [ $lines_above -gt 0 ]; then        echo "($lines_above
                more lines above)"    fi    cat $CURRENT_FILE | grep -n $ | head -n
                $(jq -n "[$CURRENT_LINE + $WINDOW/2, $WINDOW/2] | max | floor") |
                tail -n $(jq -n "$WINDOW")    if [ $lines_below -gt 0 ]; then        echo
                "($lines_below more lines below)"    fi}'
              docstring: null
              end_name: null
              name: _print
              signature: _print
            - arguments: null
              code: _constrain_line() {    if [ -z "$CURRENT_FILE" ]    then        echo
                "No file open. Use the open command first."        return    fi    local
                max_line=$(awk 'END {print NR}' $CURRENT_FILE)    local half_window=$(jq
                -n "$WINDOW/2" | jq 'floor')    export CURRENT_LINE=$(jq -n "[$CURRENT_LINE,
                $max_line - $half_window] | min")    export CURRENT_LINE=$(jq -n "[$CURRENT_LINE,
                $half_window] | max")}
              docstring: null
              end_name: null
              name: _constrain_line
              signature: _constrain_line
          config_file: config/configs/roles/verifier.yaml
          model:
            host_url: localhost:11434
            model_name: azure:gpt-4o-2024-05-13
            per_instance_cost_limit: 0.0
            replay_path: null
            temperature: 1.0
            top_p: 1.0
            total_cost_limit: 0.0
        agent_file: config/configs/roles/verifier.yaml
        docstring: null
        end_name: null
        init_observation: null
        model:
          host_url: localhost:11434
          model_name: azure:gpt-4o-2024-05-13
          per_instance_cost_limit: 0.0
          replay_path: null
          temperature: 1.0
          top_p: 1.0
          total_cost_limit: 0.0
        name: Tester
        return_type: traj
        signature: null
    blocklist:
    - vim
    - vi
    - emacs
    - nano
    - nohup
    - git
    blocklist_error_template: Interactive operation '{name}' is not supported by this
      environment
    blocklist_standalone:
    - python
    - python3
    - ipython
    - bash
    - sh
    - exit
    - /bin/bash
    - /bin/sh
    - nohup
    - vi
    - vim
    - emacs
    - nano
    command_docs: |
      open <path> [<line_number>] - opens the file at the given path in the editor. If line_number is provided, the window will be move to include that line
      goto <line_number> - moves the window to show <line_number>
      scroll_down - moves the window down 100 lines
      scroll_up - moves the window down 100 lines
      create <filename> - creates and opens a new file with the given name
      search_dir <search_term> [<dir>] - searches for search_term in all files in dir. If dir is not provided, searches in the current directory
      search_file <search_term> [<file>] - searches for search_term in file. If file is not provided, searches in the current open file
      find_file <file_name> [<dir>] - finds all files with the given name in dir. If dir is not provided, searches in the current directory
      rover_search_file <project_path> <file_name> - search for a file named <file_name> in <project_path> by using the project-level search engine.
      rover_search_class <project_path> <class_name> - search for a class named <class_name> in <project_path> by using the project-level search engine.
      rover_search_method <project_path> <method_name> - search for a method named <method_name> in <project_path> by using the project-level search engine.
      rover_search_code <project_path> <code> - search for a code snippet <code> in <project_path> by using the project-level search engine.
      rover_search_code_in_file <project_path> <file_name> <code> - search for a code snippet <code> in <file_name> from the directory <project_path> by using the project-level search engine.
      edit <start_line>:<end_line>
      <replacement_text>
      end_of_edit - replaces lines <start_line> through <end_line> (inclusive) with the given text in the open file. The replacement text is terminated by a line with only end_of_edit on it. All of the <replacement text> will be entered, so make sure your indentation is formatted properly. Python files will be checked for syntax errors after the edit. If the system detects a syntax error, the edit will not be executed. Simply try to edit the file again, but make sure to read the error message and modify the edit command you issue accordingly. Issuing the same command a second time will just lead to the same error message again.
      submit - submits your current code and terminates the session
      find_test_files [<directory>] - finds and lists all test files in the current or specified directory
      warning_pytest - warns the user that pytest should be run on relevant test files only
      failed_test_message - strategies to handle failed test cases
      update_plan - The plan has been updated.
      end_conversation - end the conversation
      warning_message_edit - display a warning message
      request_new_test_session - request the Debugger/Tester for an independent verification of the current state using both the original and expanded reproduction tests
      end_conversation - end the conversation
      warning_message_submit_patch - display a warning message
      request_submit_patch - request the tester to verify the patch and submit it
      warning_message_multiple_code_blocks - Display a warning message about multiple code blocks, including examples of correct formatting as a simple sequence
      warning_programmer_pytest - warns the user that pytest should be run on relevant test files only
      warning_programmer_rm - please don't remove reproduction script
    command_files:
    - /home/minkim/swe/testgen/swe_proj2/config/commands/defaults.sh
    - /home/minkim/swe/testgen/swe_proj2/config/commands/search.sh
    - /home/minkim/swe/testgen/swe_proj2/config/commands/_augmented_rover_search.py
    - /home/minkim/swe/testgen/swe_proj2/config/commands/rover_search.sh
    - /home/minkim/swe/testgen/swe_proj2/config/commands/edit_linting.sh
    - /home/minkim/swe/testgen/swe_proj2/config/commands/_split_string.py
    - /home/minkim/swe/testgen/swe_proj2/config/commands/submit.sh
    - /home/minkim/swe/testgen/swe_proj2/config/commands/unit_test.sh
    - /home/minkim/swe/testgen/swe_proj2/config/commands/chat_debugger.sh
    - /home/minkim/swe/testgen/swe_proj2/config/commands/chat_editor.sh
    demonstration_template: |
      Here is a demonstration of how to correctly accomplish this task.
      It is included to show you how to correctly use the interface.
      You do not need to follow exactly what is done in the demonstration.
      --- DEMONSTRATION ---
      {demonstration}
      --- END OF DEMONSTRATION ---
    demonstrations: []
    env_variables:
      CURRENT_FILE: ''
      CURRENT_LINE: '0'
      OVERLAP: '2'
      SEARCH_FILES: ()
      SEARCH_INDEX: '0'
      SEARCH_RESULTS: ()
      WINDOW: '100'
    format_error_template: |
      Your output was not formatted correctly. You must always include one discussion and one command as part of your response. Make sure you do not have multiple discussion/command tags.
      Please make sure your output precisely matches the following format:
      DISCUSSION
      Discuss here with yourself about what your planning and what you're going to do in this step.

      ```
      command(s) that you're going to run
      ```
    history_processor: {}
    history_processor_args: {}
    instance_template: |-
      We're currently solving the following issue within our repository. Here's the issue text:
      ISSUE:
      {issue}

      INSTRUCTION:
      When you're satisfied with all of the changes your plan teams have made, you can submit your changes to the code base by simply running the `submit` command.

      Now, you have four plans listed as follows. You must choose one from them to solve the issue. PLEASE DO NOT MAKE A NEW PLAN.
      **Plan A**
      ```
      plan
      {{
        "entry": "Reproducer",
        "roles": [
          {{
            "name": "Reproducer",
            "attributes": {{
              "task": "Generate test scripts based on the issue description yourself. Paste it into `path/to/reproduce.py`. Run `path/to/reproduce.py` and compare error messages with those in the description. If successfully reproduced, forward the error message to the Debugger. If not, forward \"cannot reproduce\" to the Programmer.",
              "constraint": "",
              "downstream": {{
                "succeed": {{
                  "to": "Debugger",
                  "info": "ErrMsg"
                }},
                "fail": {{
                  "to": "Programmer",
                  "info": "Plan Failed"
                }}
              }}
            }}
          }},
          {{
            "name": "Debugger",
            "attributes": {{
              "task": "You will now take the role of a tester and fault localizer, communicating with a Programmer (who will edit the code to fix the issue). First, run the reproduction script and relevant unit tests, by identify the tests that are relevant to the issue, identify the failing tests. Second, add any additional tests that are needed to ensure the issue is fixed robustly. Then, ask the Programmer to modify the code to fix the issue, based on the plan.",
              "constraint": "",
              "downstream": {{
                "succeed": {{
                  "to": "Programmer",
                  "info": "FilesToModify,FunctionsToModify"
                }},
                "fail": {{
                  "to": "Programmer",
                  "info": "N/A"
                }}
              }}
            }}
          }},
          {{
            "name": "Programmer",
            "attributes": {{
              "task": "",
              "constraint": "",
              "downstream": {{
                "succeed": {{
                  "to": "Tester",
                  "info": "Patch"
                }},
                "fail": {{
                  "to": "Manager",
                  "info": "PlanFailed"
                }}
              }}
            }}
          }},
          {{
          "name": "Tester",
          "attributes": {{
            "task": "Test whether the issue has been fixed.",
            "constraint": "",
            "downstream": {{
              "succeed": {{
                "to": "Manager",
                "info": "Patch"
              }},
              "fail": {{
                "to": "Manager",
                "info": "PlanFailed"
              }}
            }}
          }}
        }}
        ]
      }}
      end_of_plan
      ```



      IMPORTANT TIPS:
      1. If the issue description contains a user provided test but does not contain a set of developer tests, use **Plan A**.

      2. If the issue description does not contain a user provided test and a set of developer tests, use **Plan B**.

      3. Note, the content of the plan needs to be wrapped with `plan` and `end_of_plan`, enclosed by ```.
      You should only include a *SINGLE* command in the command section and then wait for a response with more discussions. Everything you include in the DISCUSSION section will be saved for future reference.
      If you'd like to issue two plans or commands at once, PLEASE DO NOT DO THAT!

      4. If a plan does not produce an output or fails to execute, consider using another plan.

      5. The plan command you have made must be under the COMMAND section, not in the DISCUSSION. Otherwise it will be difficult to extract.

      6. You are required to select one of the two presented plans above, NOT DESIGNING A NEW PLAN.

      (Open file: {open_file})
      (Current directory: {working_dir})
      bash-$
    multi_roles_transfer_template: null
    next_step_no_output_template: |-
      Your command ran successfully and did not produce any output.
      (Open file: {open_file})
      (Current directory: {working_dir})
      bash-$
    next_step_template: |-
      {observation}
      (Open file: {open_file})
      (Current directory: {working_dir})
      bash-$
    parse_command: {}
    parse_function: {}
    planer_command:
      arguments: null
      code: null
      docstring: null
      end_name: end_of_plan
      name: plan
      signature: null
    put_demos_in_history: false
    state_command:
      arguments: null
      code: |
        state() {
          local working_dir="$PWD";
          if [ -z $CURRENT_FILE ]; then
              echo '{"open_file": "n/a", "working_dir": "'$working_dir'"}';
          else
              echo '{"open_file": "'$(realpath $CURRENT_FILE)'", "working_dir": "'$working_dir'"}';
          fi
        };
      docstring: null
      end_name: null
      name: state
      signature: null
    strategy_template: null
    submit_command: submit
    subroutine_types:
    - agent_args:
        config:
          _commands:
          - arguments:
              line_number:
                description: the line number to move the window to (if not provided,
                  the window will start at the top of the file)
                required: false
                type: integer
              path:
                description: the path to the file to open
                required: true
                type: string
            code: 'open() {    if [ -z "$1" ]    then        echo "Usage: open <file>"        return    fi    #
              Check if the second argument is provided    if [ -n "$2" ]; then        #
              Check if the provided argument is a valid number        if ! [[ $2 =~
              ^[0-9]+$ ]]; then            echo "Usage: open <file> [<line_number>]"            echo
              "Error: <line_number> must be a number"            return  # Exit if
              the line number is not valid        fi        local max_line=$(awk ''END
              {print NR}'' $1)        if [ $2 -gt $max_line ]; then            echo
              "Warning: <line_number> ($2) is greater than the number of lines in
              the file ($max_line)"            echo "Warning: Setting <line_number>
              to $max_line"            local line_number=$(jq -n "$max_line")  # Set
              line number to max if greater than max        elif [ $2 -lt 1 ]; then            echo
              "Warning: <line_number> ($2) is less than 1"            echo "Warning:
              Setting <line_number> to 1"            local line_number=$(jq -n "1")  #
              Set line number to 1 if less than 1        else            local OFFSET=$(jq
              -n "$WINDOW/6" | jq ''floor'')            local line_number=$(jq -n
              "[$2 + $WINDOW/2 - $OFFSET, 1] | max | floor")        fi    else        local
              line_number=$(jq -n "$WINDOW/2")  # Set default line number if not provided    fi    if
              [ -f "$1" ]; then        export CURRENT_FILE=$(realpath $1)        export
              CURRENT_LINE=$line_number        _constrain_line        _print    elif
              [ -d "$1" ]; then        echo "Error: $1 is a directory. You can only
              open files. Use cd or ls to navigate directories."    else        echo
              "File $1 not found"    fi}'
            docstring: opens the file at the given path in the editor. If line_number
              is provided, the window will be move to include that line
            end_name: null
            name: open
            signature: open <path> [<line_number>]
          - arguments:
              line_number:
                description: the line number to move the window to
                required: true
                type: integer
            code: 'goto() {    if [ $# -gt 1 ]; then        echo "goto allows only
              one line number at a time."        return    fi    if [ -z "$CURRENT_FILE"
              ]    then        echo "No file open. Use the open command first."        return    fi    if
              [ -z "$1" ]    then        echo "Usage: goto <line>"        return    fi    if
              ! [[ $1 =~ ^[0-9]+$ ]]    then        echo "Usage: goto <line>"        echo
              "Error: <line> must be a number"        return    fi    local max_line=$(awk
              ''END {print NR}'' $CURRENT_FILE)    if [ $1 -gt $max_line ]    then        echo
              "Error: <line> must be less than or equal to $max_line"        return    fi    local
              OFFSET=$(jq -n "$WINDOW/6" | jq ''floor'')    export CURRENT_LINE=$(jq
              -n "[$1 + $WINDOW/2 - $OFFSET, 1] | max | floor")    _constrain_line    _print}'
            docstring: moves the window to show <line_number>
            end_name: null
            name: goto
            signature: goto <line_number>
          - arguments: null
            code: scroll_down() {    if [ -z "$CURRENT_FILE" ]    then        echo
              "No file open. Use the open command first."        return    fi    export
              CURRENT_LINE=$(jq -n "$CURRENT_LINE + $WINDOW - $OVERLAP")    _constrain_line    _print}
            docstring: moves the window down {WINDOW} lines
            end_name: null
            name: scroll_down
            signature: scroll_down
          - arguments: null
            code: scroll_up() {    if [ -z "$CURRENT_FILE" ]    then        echo "No
              file open. Use the open command first."        return    fi    export
              CURRENT_LINE=$(jq -n "$CURRENT_LINE - $WINDOW + $OVERLAP")    _constrain_line    _print}
            docstring: moves the window down {WINDOW} lines
            end_name: null
            name: scroll_up
            signature: scroll_up
          - arguments:
              filename:
                description: the name of the file to create
                required: true
                type: string
            code: "create() {    if [ -z \"$1\" ]; then        echo \"Usage: create\
              \ <filename>\"        return    fi    # Check if the file already exists\
              \    if [ -e \"$1\" ]; then        echo \"Error: File '$1' already exists.\"\
              \t\topen \"$1\"        return    fi    # Create the file an empty new\
              \ line    printf \"\\n\" > \"$1\"    # Use the existing open command\
              \ to open the created file    open \"$1\"}"
            docstring: creates and opens a new file with the given name
            end_name: null
            name: create
            signature: create <filename>
          - arguments:
              dir:
                description: the directory to search in (if not provided, searches
                  in the current directory)
                required: false
                type: string
              search_term:
                description: the term to search for
                required: true
                type: string
            code: 'search_dir() {    if [ $# -eq 1 ]; then        local search_term="$1"        local
              dir="./"    elif [ $# -eq 2 ]; then        local search_term="$1"        if
              [ -d "$2" ]; then            local dir="$2"        else            echo
              "Directory $2 not found"            return        fi    else        echo
              "Usage: search_dir <search_term> [<dir>]"        return    fi    dir=$(realpath
              "$dir")    local matches=$(find "$dir" -type f ! -path ''*/.*'' -exec
              grep -nIH -- "$search_term" {} + | cut -d: -f1 | sort | uniq -c)    #
              if no matches, return    if [ -z "$matches" ]; then        echo "No
              matches found for \"$search_term\" in $dir"        return    fi    #
              Calculate total number of matches    local num_matches=$(echo "$matches"
              | awk ''{sum+=$1} END {print sum}'')    # calculate total number of
              files matched    local num_files=$(echo "$matches" | wc -l | awk ''{$1=$1;
              print $0}'')    # if num_files is > 100, print an error    if [ $num_files
              -gt 100 ]; then        echo "More than $num_files files matched for
              \"$search_term\" in $dir. Please narrow your search."        return    fi    echo
              "Found $num_matches matches for \"$search_term\" in $dir:"    echo "$matches"
              | awk ''{$2=$2; gsub(/^\.+\/+/, "./", $2); print $2 " ("$1" matches)"}''    echo
              "End of matches for \"$search_term\" in $dir"}'
            docstring: searches for search_term in all files in dir. If dir is not
              provided, searches in the current directory
            end_name: null
            name: search_dir
            signature: search_dir <search_term> [<dir>]
          - arguments:
              file:
                description: the file to search in (if not provided, searches in the
                  current open file)
                required: false
                type: string
              search_term:
                description: the term to search for
                required: true
                type: string
            code: 'search_file() {    # Check if the first argument is provided    if
              [ -z "$1" ]; then        echo "Usage: search_file <search_term> [<file>]"        return    fi    #
              Check if the second argument is provided    if [ -n "$2" ]; then        #
              Check if the provided argument is a valid file        if [ -f "$2" ];
              then            local file="$2"  # Set file if valid        else            echo
              "Usage: search_file <search_term> [<file>]"            echo "Error:
              File name $2 not found. Please provide a valid file name."            return  #
              Exit if the file is not valid        fi    else        # Check if a
              file is open        if [ -z "$CURRENT_FILE" ]; then            echo
              "No file open. Use the open command first."            return  # Exit
              if no file is open        fi        local file="$CURRENT_FILE"  # Set
              file to the current open file    fi    local search_term="$1"    file=$(realpath
              "$file")    # Use grep to directly get the desired formatted output    local
              matches=$(grep -nH -- "$search_term" "$file")    # Check if no matches
              were found    if [ -z "$matches" ]; then        echo "No matches found
              for \"$search_term\" in $file"        return    fi    # Calculate total
              number of matches    local num_matches=$(echo "$matches" | wc -l | awk
              ''{$1=$1; print $0}'')    # calculate total number of lines matched    local
              num_lines=$(echo "$matches" | cut -d: -f1 | sort | uniq | wc -l | awk
              ''{$1=$1; print $0}'')    # if num_lines is > 100, print an error    if
              [ $num_lines -gt 100 ]; then        echo "More than $num_lines lines
              matched for \"$search_term\" in $file. Please narrow your search."        return    fi    #
              Print the total number of matches and the matches themselves    echo
              "Found $num_matches matches for \"$search_term\" in $file:"    echo
              "$matches" | cut -d: -f1-2 | sort -u -t: -k2,2n | while IFS=: read -r
              filename line_number; do        echo "Line $line_number:$(sed -n "${line_number}p"
              "$file")"    done    echo "End of matches for \"$search_term\" in $file"}'
            docstring: searches for search_term in file. If file is not provided,
              searches in the current open file
            end_name: null
            name: search_file
            signature: search_file <search_term> [<file>]
          - arguments:
              dir:
                description: the directory to search in (if not provided, searches
                  in the current directory)
                required: false
                type: string
              file_name:
                description: the name of the file to search for
                required: true
                type: string
            code: 'find_file() {    if [ $# -eq 1 ]; then        local file_name="$1"        local
              dir="./"    elif [ $# -eq 2 ]; then        local file_name="$1"        if
              [ -d "$2" ]; then            local dir="$2"        else            echo
              "Directory $2 not found"            return        fi    else        echo
              "Usage: find_file <file_name> [<dir>]"        return    fi    dir=$(realpath
              "$dir")    local matches=$(find "$dir" -type f -name "$file_name")    #
              if no matches, return    if [ -z "$matches" ]; then        echo "No
              matches found for \"$file_name\" in $dir"        return    fi    # Calculate
              total number of matches    local num_matches=$(echo "$matches" | wc
              -l | awk ''{$1=$1; print $0}'')    echo "Found $num_matches matches
              for \"$file_name\" in $dir:"    echo "$matches" | awk ''{print $0}''}'
            docstring: finds all files with the given name in dir. If dir is not provided,
              searches in the current directory
            end_name: null
            name: find_file
            signature: find_file <file_name> [<dir>]
          - arguments:
              end_line:
                description: the line number to end the edit at (inclusive)
                required: true
                type: integer
              replacement_text:
                description: the text to replace the current selection with
                required: true
                type: string
              start_line:
                description: the line number to start the edit at
                required: true
                type: integer
            code: 'edit() {    if [ -z "$CURRENT_FILE" ]    then        echo ''No
              file open. Use the `open` command first.''        return    fi    local
              start_line="$(echo $1: | cut -d: -f1)"    local end_line="$(echo $1:
              | cut -d: -f2)"    if [ -z "$start_line" ] || [ -z "$end_line" ]    then        echo
              "Usage: edit <start_line>:<end_line>"        return    fi    local re=''^[0-9]+$''    if
              ! [[ $start_line =~ $re ]]; then        echo "Usage: edit <start_line>:<end_line>"        echo
              "Error: start_line must be a number"        return    fi    if ! [[
              $end_line =~ $re ]]; then        echo "Usage: edit <start_line>:<end_line>"        echo
              "Error: end_line must be a number"        return    fi    # Bash array
              starts at 0, so let''s adjust    local start_line=$((start_line - 1))    local
              end_line=$((end_line))    local line_count=0    local replacement=()    while
              IFS= read -r line    do        replacement+=("$line")        ((line_count++))    done    #
              Create a backup of the current file    cp "$CURRENT_FILE" "/root/$(basename
              "$CURRENT_FILE")_backup"    # Read the file line by line into an array    mapfile
              -t lines < "$CURRENT_FILE"    local new_lines=("${lines[@]:0:$start_line}"
              "${replacement[@]}" "${lines[@]:$((end_line))}")    # Write the new
              stuff directly back into the original file    printf "%s\n" "${new_lines[@]}"
              >| "$CURRENT_FILE"    # Run linter    if [[ $CURRENT_FILE == *.py ]];
              then        lint_output=$(flake8 --isolated --select=F821,F822,F831,E111,E112,E113,E999,E902
              "$CURRENT_FILE" 2>&1)    else        # do nothing        lint_output=""    fi    #
              if there is no output, then the file is good    if [ -z "$lint_output"
              ]; then        export CURRENT_LINE=$start_line        _constrain_line        _print        echo
              "File updated. Please review the changes and make sure they are correct
              (correct indentation, no duplicate lines, etc). Edit the file again
              if necessary."    else        echo "Your proposed edit has introduced
              new syntax error(s). Please read this error message carefully and then
              retry editing the file."        echo ""        echo "ERRORS:"        _split_string
              "$lint_output"        echo ""        # Save original values        original_current_line=$CURRENT_LINE        original_window=$WINDOW        #
              Update values        export CURRENT_LINE=$(( (line_count / 2) + start_line
              )) # Set to "center" of edit        export WINDOW=$((line_count + 10))
              # Show +/- 5 lines around edit        echo "This is how your edit would
              have looked if applied"        echo "-------------------------------------------------"        _constrain_line        _print        echo
              "-------------------------------------------------"        echo ""        #
              Restoring CURRENT_FILE to original contents.        cp "/root/$(basename
              "$CURRENT_FILE")_backup" "$CURRENT_FILE"        export CURRENT_LINE=$((
              ((end_line - start_line + 1) / 2) + start_line ))        export WINDOW=$((end_line
              - start_line + 10))        echo "This is the original code before your
              edit"        echo "-------------------------------------------------"        _constrain_line        _print        echo
              "-------------------------------------------------"        # Restore
              original values        export CURRENT_LINE=$original_current_line        export
              WINDOW=$original_window        echo "Your changes have NOT been applied.
              Please fix your edit command and try again."        echo "You either
              need to 1) Specify the correct start/end line arguments or 2) Correct
              your edit code."        echo "DO NOT re-run the same failed edit command.
              Running it again will lead to the same error."    fi    # Remove backup
              file    rm -f "/root/$(basename "$CURRENT_FILE")_backup"}'
            docstring: replaces lines <start_line> through <end_line> (inclusive)
              with the given text in the open file. The replacement text is terminated
              by a line with only end_of_edit on it. All of the <replacement text>
              will be entered, so make sure your indentation is formatted properly.
              Python files will be checked for syntax errors after the edit. If the
              system detects a syntax error, the edit will not be executed. Simply
              try to edit the file again, but make sure to read the error message
              and modify the edit command you issue accordingly. Issuing the same
              command a second time will just lead to the same error message again.
            end_name: end_of_edit
            name: edit
            signature: |-
              edit <start_line>:<end_line>
              <replacement_text>
              end_of_edit
          _subroutines: {}
          blocklist:
          - vim
          - vi
          - emacs
          - nano
          - nohup
          - git
          blocklist_error_template: Interactive operation '{name}' is not supported
            by this environment
          blocklist_standalone:
          - python
          - python3
          - ipython
          - bash
          - sh
          - exit
          - /bin/bash
          - /bin/sh
          - nohup
          - vi
          - vim
          - emacs
          - nano
          command_docs: |+
            open:
              docstring: opens the file at the given path in the editor. If line_number is provided, the window will be move to include that line
              signature: open <path> [<line_number>]
              arguments:
                - path (string) [required]: the path to the file to open
                - line_number (integer) [optional]: the line number to move the window to (if not provided, the window will start at the top of the file)

            goto:
              docstring: moves the window to show <line_number>
              signature: goto <line_number>
              arguments:
                - line_number (integer) [required]: the line number to move the window to

            scroll_down:
              docstring: moves the window down {WINDOW} lines
              signature: scroll_down

            scroll_up:
              docstring: moves the window down {WINDOW} lines
              signature: scroll_up

            create:
              docstring: creates and opens a new file with the given name
              signature: create <filename>
              arguments:
                - filename (string) [required]: the name of the file to create

            search_dir:
              docstring: searches for search_term in all files in dir. If dir is not provided, searches in the current directory
              signature: search_dir <search_term> [<dir>]
              arguments:
                - search_term (string) [required]: the term to search for
                - dir (string) [optional]: the directory to search in (if not provided, searches in the current directory)

            search_file:
              docstring: searches for search_term in file. If file is not provided, searches in the current open file
              signature: search_file <search_term> [<file>]
              arguments:
                - search_term (string) [required]: the term to search for
                - file (string) [optional]: the file to search in (if not provided, searches in the current open file)

            find_file:
              docstring: finds all files with the given name in dir. If dir is not provided, searches in the current directory
              signature: find_file <file_name> [<dir>]
              arguments:
                - file_name (string) [required]: the name of the file to search for
                - dir (string) [optional]: the directory to search in (if not provided, searches in the current directory)

            edit:
              docstring: replaces lines <start_line> through <end_line> (inclusive) with the given text in the open file. The replacement text is terminated by a line with only end_of_edit on it. All of the <replacement text> will be entered, so make sure your indentation is formatted properly. Python files will be checked for syntax errors after the edit. If the system detects a syntax error, the edit will not be executed. Simply try to edit the file again, but make sure to read the error message and modify the edit command you issue accordingly. Issuing the same command a second time will just lead to the same error message again.
              signature: edit <start_line>:<end_line>
            <replacement_text>
            end_of_edit
              arguments:
                - start_line (integer) [required]: the line number to start the edit at
                - end_line (integer) [required]: the line number to end the edit at (inclusive)
                - replacement_text (string) [required]: the text to replace the current selection with

          command_files:
          - /home/minkim/swe/testgen/swe_proj2/config/commands/defaults.sh
          - /home/minkim/swe/testgen/swe_proj2/config/commands/search.sh
          - /home/minkim/swe/testgen/swe_proj2/config/commands/edit_linting.sh
          - /home/minkim/swe/testgen/swe_proj2/config/commands/_split_string.py
          demonstration_template: |
            Here is a demonstration of how to correctly accomplish this task.
            It is included to show you how to correctly use the interface.
            You do not need to follow exactly what is done in the demonstration.
            --- DEMONSTRATION ---
            {demonstration}
            --- END OF DEMONSTRATION ---
          demonstrations: []
          env_variables:
            CURRENT_FILE: ''
            CURRENT_LINE: '0'
            OVERLAP: '2'
            SEARCH_FILES: ()
            SEARCH_INDEX: '0'
            SEARCH_RESULTS: ()
            WINDOW: '100'
          format_error_template: |
            Your output was not formatted correctly. You must always include one discussion and one command as part of your response. Make sure you do not have multiple discussion/command tags.
            Please make sure your output precisely matches the following format:
            DISCUSSION
            Discuss here with yourself about what your planning and what you're going to do in this step.

            ```
            command(s) that you're going to run
            ```
          history_processor: {}
          history_processor_args:
            n: 5
          instance_template: "We're currently solving the following issue within our\
            \ repository. Here's the issue text:\nISSUE:\n{issue}\n\nINSTRUCTIONS:\n\
            Now, you're going to solve this issue on your own. Your terminal session\
            \ has started and you're in the repository's root directory. You can use\
            \ any bash commands or the special interface to help you. Edit all the\
            \ files you need to and run any checks or tests that you want.\nRemember,\
            \ YOU CAN ONLY ENTER ONE COMMAND AT A TIME. You should always wait for\
            \ feedback after every command.\nWhen you're satisfied with all of the\
            \ changes you've made, you can submit your changes to the code base by\
            \ simply running the submit command.\nNote however that you cannot use\
            \ any interactive session commands (e.g. python, vim) in this environment,\
            \ but you can write scripts and run them. E.g. you can write a python\
            \ script and then run it with `python <script_name>.py`.\n\nNOTE ABOUT\
            \ THE EDIT COMMAND: Indentation really matters! When editing a file, make\
            \ sure to insert appropriate indentation before each line!\n\n\nIMPORTANT\
            \ TIPS:\n1. Always start by trying to replicate the bug that the issues\
            \ discusses.\n  If the issue includes code for reproducing the bug, we\
            \ recommend that you re-implement that in your environment, and run it\
            \ to make sure you can reproduce the bug.\n  Then start trying to fix\
            \ it.\n  When you think you've fixed the bug, re-run the bug reproduction\
            \ script to make sure that the bug has indeed been fixed.\n\n\n2. If you\
            \ run a command and it doesn't work, try running a different command.\
            \ A command that did not work once will not work the second time unless\
            \ you modify it!\n\n3. If you open a file and need to get to an area around\
            \ a specific line that is not in the first 100 lines, say line 583, don't\
            \ just use the scroll_down command multiple times. Instead, use the goto\
            \ 583 command. It's much quicker.\n\n4. If the bug reproduction script\
            \ requires inputting/reading a specific file, such as buggy-input.png,\
            \ and you'd like to understand how to input that file, conduct a search\
            \ in the existing repo code, to see whether someone else has already done\
            \ that. Do this by running the command: find_file \"buggy-input.png\"\
            \ If that doesn't work, use the linux 'find' command.\n\n5. Always make\
            \ sure to look at the currently open file and the current working directory\
            \ (which appears right after the currently open file). The currently open\
            \ file might be in a different directory than the working directory! Note\
            \ that some commands, such as 'create', open files, so they might change\
            \ the current  open file.\n\n6. When editing files, it is easy to accidentally\
            \ specify a wrong line number or to write code with incorrect indentation.\
            \ Always check the code after you issue an edit to make sure that it reflects\
            \ what you wanted to accomplish. If it didn't, issue another command to\
            \ fix it.\n\n7. Only return \"succeed\" command when the current task\
            \ is truly completed. If the current task still cannot be completed after\
            \ trying many different solutions, please return \"fail\" command. The\
            \ final output format is as follows:    "
          multi_roles_transfer_template: |
            You are currently in a team organized by a manager, where each role has its own tasks. Everyone is working together to solve this issue. Here is some information about the team.
            {history_conclusion}

            CURRENT STATE
            (Open file: {open_file})
            (Current directory: {working_dir})
            bash-$
          next_step_no_output_template: |-
            Your command ran successfully and did not produce any output.
            (Open file: {open_file})
            (Current directory: {working_dir})
            bash-$
          next_step_template: |-
            {observation}
            (Open file: {open_file})
            (Current directory: {working_dir})
            bash-$
          parse_command: {}
          parse_function: {}
          planer_command:
            arguments: null
            code: null
            docstring: null
            end_name: end_of_plan
            name: plan
            signature: null
          put_demos_in_history: false
          state_command:
            arguments: null
            code: |
              state() {
                local working_dir="$PWD";
                if [ -z $CURRENT_FILE ]; then
                    echo '{"open_file": "n/a", "working_dir": "'$working_dir'"}';
                else
                    echo '{"open_file": "'$(realpath $CURRENT_FILE)'", "working_dir": "'$working_dir'"}';
                fi
              };
            docstring: null
            end_name: null
            name: state
            signature: null
          strategy_template: null
          submit_command: submit
          subroutine_types: []
          system_template: "SETTING: You are a helpful assistant tasked with writing\
            \ tests to reproduce a specified issue, and you're working directly in\
            \ the command line with a special interface.\n\nThe special interface\
            \ consists of a file editor that shows you {WINDOW} lines of a file at\
            \ a time.\nIn addition to typical bash commands, you can also use the\
            \ following commands to help you navigate and edit files.\n\nCOMMANDS:\n\
            {command_docs}\n\nPlease note that THE EDIT COMMAND REQUIRES PROPER INDENTATION.\
            \ \nIf you'd like to add the line '        print(x)' you must fully write\
            \ that out, with all those spaces before the code! Indentation is important\
            \ and code that is not indented correctly will fail and require fixing\
            \ before it can be run.\n\nRESPONSE FORMAT:\nYour shell prompt is formatted\
            \ as follows:\n(Open file: <path>) <cwd> $\n\nYou need to format your\
            \ output using two fields; discussion and command.\nYour output should\
            \ always include _one_ discussion and _one_ command field EXACTLY as in\
            \ the following example:\nDISCUSSION\nFirst I'll start by using ls to\
            \ see what files are in the current directory. Then maybe we can look\
            \ at some relevant files to see what they look like.\n```\nls -a\n```\n\
            \nYou should only include a *SINGLE* command in the command section and\
            \ then wait for a response from the shell before continuing with more\
            \ discussion and commands. Everything you include in the DISCUSSION section\
            \ will be saved for future reference.\nIf you'd like to issue two commands\
            \ at once, PLEASE DO NOT DO THAT! Please instead first submit just the\
            \ first command, and then after receiving a response you'll be able to\
            \ issue the second command. \nYou're free to use any other bash commands\
            \ you want (e.g. find, grep, cat, ls, cd) in addition to the special commands\
            \ listed above.\nHowever, the environment does NOT support interactive\
            \ session commands (e.g. vi, vim), so please do not invoke them.\n\nOnce\
            \ you make *NO PROGRESS* on current task, you should stop generating next\
            \ action. Instead, if current task is succeeded, you should output `succeed`.\
            \ If failed, you should output `fail`.\nRESPONSE FORMAT:\nYour output\
            \ should always contains a SUMMARY OF ALL ACTIONS PERFORMED and the TASK\
            \ STATUS (`succeed` or `fail`). \nDISCUSSION\nThrough the analysis of\
            \ the issue and the search within the project, the issue has been reproduced\
            \ in the `reproduce.py` file.\n```\nsucceed\n```\n\nIMPORTANT TIPS: your\
            \ job is reproduce the bug described in the issue USING A NEWLY CREATED\
            \ FILE NAMED `reproduce.py`. DO NOT EDIT THE CODE IN THE REPOSITORY!!!"
          util_functions:
          - arguments: null
            code: '_print() {    local total_lines=$(awk ''END {print NR}'' $CURRENT_FILE)    echo
              "[File: $(realpath $CURRENT_FILE) ($total_lines lines total)]"    lines_above=$(jq
              -n "$CURRENT_LINE - $WINDOW/2" | jq ''[0, .] | max | floor'')    lines_below=$(jq
              -n "$total_lines - $CURRENT_LINE - $WINDOW/2" | jq ''[0, .] | max |
              round'')    if [ $lines_above -gt 0 ]; then        echo "($lines_above
              more lines above)"    fi    cat $CURRENT_FILE | grep -n $ | head -n
              $(jq -n "[$CURRENT_LINE + $WINDOW/2, $WINDOW/2] | max | floor") | tail
              -n $(jq -n "$WINDOW")    if [ $lines_below -gt 0 ]; then        echo
              "($lines_below more lines below)"    fi}'
            docstring: null
            end_name: null
            name: _print
            signature: _print
          - arguments: null
            code: _constrain_line() {    if [ -z "$CURRENT_FILE" ]    then        echo
              "No file open. Use the open command first."        return    fi    local
              max_line=$(awk 'END {print NR}' $CURRENT_FILE)    local half_window=$(jq
              -n "$WINDOW/2" | jq 'floor')    export CURRENT_LINE=$(jq -n "[$CURRENT_LINE,
              $max_line - $half_window] | min")    export CURRENT_LINE=$(jq -n "[$CURRENT_LINE,
              $half_window] | max")}
            docstring: null
            end_name: null
            name: _constrain_line
            signature: _constrain_line
        config_file: config/configs/roles/reproducer.yaml
        model:
          host_url: localhost:11434
          model_name: azure:gpt-4o-2024-05-13
          per_instance_cost_limit: 0.0
          replay_path: null
          temperature: 1.0
          top_p: 1.0
          total_cost_limit: 0.0
      agent_file: config/configs/roles/reproducer.yaml
      docstring: null
      end_name: null
      init_observation: null
      model:
        host_url: localhost:11434
        model_name: azure:gpt-4o-2024-05-13
        per_instance_cost_limit: 0.0
        replay_path: null
        temperature: 1.0
        top_p: 1.0
        total_cost_limit: 0.0
      name: Reproducer
      return_type: traj
      signature: null
    - agent_args:
        config:
          _commands:
          - arguments:
              line_number:
                description: the line number to move the window to (if not provided,
                  the window will start at the top of the file)
                required: false
                type: integer
              path:
                description: the path to the file to open
                required: true
                type: string
            code: 'open() {    if [ -z "$1" ]    then        echo "Usage: open <file>"        return    fi    #
              Check if the second argument is provided    if [ -n "$2" ]; then        #
              Check if the provided argument is a valid number        if ! [[ $2 =~
              ^[0-9]+$ ]]; then            echo "Usage: open <file> [<line_number>]"            echo
              "Error: <line_number> must be a number"            return  # Exit if
              the line number is not valid        fi        local max_line=$(awk ''END
              {print NR}'' $1)        if [ $2 -gt $max_line ]; then            echo
              "Warning: <line_number> ($2) is greater than the number of lines in
              the file ($max_line)"            echo "Warning: Setting <line_number>
              to $max_line"            local line_number=$(jq -n "$max_line")  # Set
              line number to max if greater than max        elif [ $2 -lt 1 ]; then            echo
              "Warning: <line_number> ($2) is less than 1"            echo "Warning:
              Setting <line_number> to 1"            local line_number=$(jq -n "1")  #
              Set line number to 1 if less than 1        else            local OFFSET=$(jq
              -n "$WINDOW/6" | jq ''floor'')            local line_number=$(jq -n
              "[$2 + $WINDOW/2 - $OFFSET, 1] | max | floor")        fi    else        local
              line_number=$(jq -n "$WINDOW/2")  # Set default line number if not provided    fi    if
              [ -f "$1" ]; then        export CURRENT_FILE=$(realpath $1)        export
              CURRENT_LINE=$line_number        _constrain_line        _print    elif
              [ -d "$1" ]; then        echo "Error: $1 is a directory. You can only
              open files. Use cd or ls to navigate directories."    else        echo
              "File $1 not found"    fi}'
            docstring: opens the file at the given path in the editor. If line_number
              is provided, the window will be move to include that line
            end_name: null
            name: open
            signature: open <path> [<line_number>]
          - arguments:
              line_number:
                description: the line number to move the window to
                required: true
                type: integer
            code: 'goto() {    if [ $# -gt 1 ]; then        echo "goto allows only
              one line number at a time."        return    fi    if [ -z "$CURRENT_FILE"
              ]    then        echo "No file open. Use the open command first."        return    fi    if
              [ -z "$1" ]    then        echo "Usage: goto <line>"        return    fi    if
              ! [[ $1 =~ ^[0-9]+$ ]]    then        echo "Usage: goto <line>"        echo
              "Error: <line> must be a number"        return    fi    local max_line=$(awk
              ''END {print NR}'' $CURRENT_FILE)    if [ $1 -gt $max_line ]    then        echo
              "Error: <line> must be less than or equal to $max_line"        return    fi    local
              OFFSET=$(jq -n "$WINDOW/6" | jq ''floor'')    export CURRENT_LINE=$(jq
              -n "[$1 + $WINDOW/2 - $OFFSET, 1] | max | floor")    _constrain_line    _print}'
            docstring: moves the window to show <line_number>
            end_name: null
            name: goto
            signature: goto <line_number>
          - arguments: null
            code: scroll_down() {    if [ -z "$CURRENT_FILE" ]    then        echo
              "No file open. Use the open command first."        return    fi    export
              CURRENT_LINE=$(jq -n "$CURRENT_LINE + $WINDOW - $OVERLAP")    _constrain_line    _print}
            docstring: moves the window down {WINDOW} lines
            end_name: null
            name: scroll_down
            signature: scroll_down
          - arguments: null
            code: scroll_up() {    if [ -z "$CURRENT_FILE" ]    then        echo "No
              file open. Use the open command first."        return    fi    export
              CURRENT_LINE=$(jq -n "$CURRENT_LINE - $WINDOW + $OVERLAP")    _constrain_line    _print}
            docstring: moves the window down {WINDOW} lines
            end_name: null
            name: scroll_up
            signature: scroll_up
          - arguments:
              filename:
                description: the name of the file to create
                required: true
                type: string
            code: "create() {    if [ -z \"$1\" ]; then        echo \"Usage: create\
              \ <filename>\"        return    fi    # Check if the file already exists\
              \    if [ -e \"$1\" ]; then        echo \"Error: File '$1' already exists.\"\
              \t\topen \"$1\"        return    fi    # Create the file an empty new\
              \ line    printf \"\\n\" > \"$1\"    # Use the existing open command\
              \ to open the created file    open \"$1\"}"
            docstring: creates and opens a new file with the given name
            end_name: null
            name: create
            signature: create <filename>
          - arguments:
              dir:
                description: the directory to search in (if not provided, searches
                  in the current directory)
                required: false
                type: string
              search_term:
                description: the term to search for
                required: true
                type: string
            code: 'search_dir() {    if [ $# -eq 1 ]; then        local search_term="$1"        local
              dir="./"    elif [ $# -eq 2 ]; then        local search_term="$1"        if
              [ -d "$2" ]; then            local dir="$2"        else            echo
              "Directory $2 not found"            return        fi    else        echo
              "Usage: search_dir <search_term> [<dir>]"        return    fi    dir=$(realpath
              "$dir")    local matches=$(find "$dir" -type f ! -path ''*/.*'' -exec
              grep -nIH -- "$search_term" {} + | cut -d: -f1 | sort | uniq -c)    #
              if no matches, return    if [ -z "$matches" ]; then        echo "No
              matches found for \"$search_term\" in $dir"        return    fi    #
              Calculate total number of matches    local num_matches=$(echo "$matches"
              | awk ''{sum+=$1} END {print sum}'')    # calculate total number of
              files matched    local num_files=$(echo "$matches" | wc -l | awk ''{$1=$1;
              print $0}'')    # if num_files is > 100, print an error    if [ $num_files
              -gt 100 ]; then        echo "More than $num_files files matched for
              \"$search_term\" in $dir. Please narrow your search."        return    fi    echo
              "Found $num_matches matches for \"$search_term\" in $dir:"    echo "$matches"
              | awk ''{$2=$2; gsub(/^\.+\/+/, "./", $2); print $2 " ("$1" matches)"}''    echo
              "End of matches for \"$search_term\" in $dir"}'
            docstring: searches for search_term in all files in dir. If dir is not
              provided, searches in the current directory
            end_name: null
            name: search_dir
            signature: search_dir <search_term> [<dir>]
          - arguments:
              file:
                description: the file to search in (if not provided, searches in the
                  current open file)
                required: false
                type: string
              search_term:
                description: the term to search for
                required: true
                type: string
            code: 'search_file() {    # Check if the first argument is provided    if
              [ -z "$1" ]; then        echo "Usage: search_file <search_term> [<file>]"        return    fi    #
              Check if the second argument is provided    if [ -n "$2" ]; then        #
              Check if the provided argument is a valid file        if [ -f "$2" ];
              then            local file="$2"  # Set file if valid        else            echo
              "Usage: search_file <search_term> [<file>]"            echo "Error:
              File name $2 not found. Please provide a valid file name."            return  #
              Exit if the file is not valid        fi    else        # Check if a
              file is open        if [ -z "$CURRENT_FILE" ]; then            echo
              "No file open. Use the open command first."            return  # Exit
              if no file is open        fi        local file="$CURRENT_FILE"  # Set
              file to the current open file    fi    local search_term="$1"    file=$(realpath
              "$file")    # Use grep to directly get the desired formatted output    local
              matches=$(grep -nH -- "$search_term" "$file")    # Check if no matches
              were found    if [ -z "$matches" ]; then        echo "No matches found
              for \"$search_term\" in $file"        return    fi    # Calculate total
              number of matches    local num_matches=$(echo "$matches" | wc -l | awk
              ''{$1=$1; print $0}'')    # calculate total number of lines matched    local
              num_lines=$(echo "$matches" | cut -d: -f1 | sort | uniq | wc -l | awk
              ''{$1=$1; print $0}'')    # if num_lines is > 100, print an error    if
              [ $num_lines -gt 100 ]; then        echo "More than $num_lines lines
              matched for \"$search_term\" in $file. Please narrow your search."        return    fi    #
              Print the total number of matches and the matches themselves    echo
              "Found $num_matches matches for \"$search_term\" in $file:"    echo
              "$matches" | cut -d: -f1-2 | sort -u -t: -k2,2n | while IFS=: read -r
              filename line_number; do        echo "Line $line_number:$(sed -n "${line_number}p"
              "$file")"    done    echo "End of matches for \"$search_term\" in $file"}'
            docstring: searches for search_term in file. If file is not provided,
              searches in the current open file
            end_name: null
            name: search_file
            signature: search_file <search_term> [<file>]
          - arguments:
              dir:
                description: the directory to search in (if not provided, searches
                  in the current directory)
                required: false
                type: string
              file_name:
                description: the name of the file to search for
                required: true
                type: string
            code: 'find_file() {    if [ $# -eq 1 ]; then        local file_name="$1"        local
              dir="./"    elif [ $# -eq 2 ]; then        local file_name="$1"        if
              [ -d "$2" ]; then            local dir="$2"        else            echo
              "Directory $2 not found"            return        fi    else        echo
              "Usage: find_file <file_name> [<dir>]"        return    fi    dir=$(realpath
              "$dir")    local matches=$(find "$dir" -type f -name "$file_name")    #
              if no matches, return    if [ -z "$matches" ]; then        echo "No
              matches found for \"$file_name\" in $dir"        return    fi    # Calculate
              total number of matches    local num_matches=$(echo "$matches" | wc
              -l | awk ''{$1=$1; print $0}'')    echo "Found $num_matches matches
              for \"$file_name\" in $dir:"    echo "$matches" | awk ''{print $0}''}'
            docstring: finds all files with the given name in dir. If dir is not provided,
              searches in the current directory
            end_name: null
            name: find_file
            signature: find_file <file_name> [<dir>]
          - arguments:
              file_name:
                description: the name of file to be searched
                required: true
                type: string
              project_path:
                description: This must be the path to the root of the project.
                required: true
                type: string
            code: rover_search_file() {    python3 /root/commands/_augmented_rover_search.py
              rover_search_file "$1" "$2"}
            docstring: search for a file named <file_name> in <project_path> by using
              the project-level search engine.
            end_name: null
            name: rover_search_file
            signature: rover_search_file <project_path> <file_name>
          - arguments:
              class_name:
                description: the name of class to be searched
                required: true
                type: string
              project_path:
                description: This must be the path to the root of the project.
                required: true
                type: string
            code: rover_search_class() {    python3 /root/commands/_augmented_rover_search.py
              rover_search_class "$1" "$2"}
            docstring: search for a class named <class_name> in <project_path> by
              using the project-level search engine.
            end_name: null
            name: rover_search_class
            signature: rover_search_class <project_path> <class_name>
          - arguments:
              method_name:
                description: the name of method to be searched
                required: true
                type: string
              project_path:
                description: This must be the path to the root of the project.
                required: true
                type: string
            code: rover_search_method() {    python3 /root/commands/_augmented_rover_search.py
              rover_search_method "$1" "$2"}
            docstring: search for a method named <method_name> in <project_path> by
              using the project-level search engine.
            end_name: null
            name: rover_search_method
            signature: rover_search_method <project_path> <method_name>
          - arguments:
              code:
                description: the code to be searched
                required: true
                type: string
              project_path:
                description: This must be the path to the root of the project.
                required: true
                type: string
            code: rover_search_code() {    python3 /root/commands/_augmented_rover_search.py
              rover_search_code "$1" "$2"}
            docstring: search for a code snippet <code> in <project_path> by using
              the project-level search engine.
            end_name: null
            name: rover_search_code
            signature: rover_search_code <project_path> <code>
          - arguments:
              code:
                description: the code to be searched
                required: true
                type: string
              file_name:
                description: the name of the file in which the <code> is to be searched.
                required: true
                type: string
              project_path:
                description: This must be the path to the root of the project.
                required: true
                type: string
            code: rover_search_code_in_file() {    python3 /root/commands/_augmented_rover_search.py
              rover_search_code_in_file "$1" "$2" "$3"}
            docstring: search for a code snippet <code> in <file_name> from the directory
              <project_path> by using the project-level search engine.
            end_name: null
            name: rover_search_code_in_file
            signature: rover_search_code_in_file <project_path> <file_name> <code>
          - arguments: null
            code: update_plan() {    echo "The plan has been updated."}
            docstring: The plan has been updated.
            end_name: null
            name: update_plan
            signature: update_plan
          - arguments: null
            code: end_conversation() {    echo "Ending the conversation."}
            docstring: end the conversation
            end_name: null
            name: end_conversation
            signature: end_conversation
          - arguments: null
            code: 'warning_message_edit() {    echo "WARNING: You attempted to edit
              the code. As a debugger, you cannot directly edit the code. Please leave
              the code editing to the programmer, by requesting the programmer to
              edit the code via update_plan command."}'
            docstring: display a warning message
            end_name: null
            name: warning_message_edit
            signature: warning_message_edit
          - arguments:
              directory:
                description: the directory to search for test files (defaults to the
                  current directory)
                required: false
                type: string
            code: 'find_test_files() {    local dir=${1:-.}        if [ ! -d "$dir"
              ]; then        echo "Error: $dir is not a valid directory."        return    fi        echo
              "Searching for test files in $dir..."        # Find files ending with
              _test.py or in a tests directory    local test_files=$(find "$dir" -type
              f \( -name ''*_test.py'' -o -path ''*/tests/*.py'' \))        if [ -z
              "$test_files" ]; then        echo "No test files found in $dir."    else        echo
              "Test files found:"        echo "$test_files"    fi}'
            docstring: finds and lists all test files in the current or specified
              directory
            end_name: null
            name: find_test_files
            signature: find_test_files [<directory>]
          - arguments: null
            code: 'warning_pytest() {    echo "Warning: Before running pytest, please
              make sure you have first identified the relevant test files (.py) for
              the issue. Run find_test_files and decide which test files are relevant.
              Please do not use keyword-based grep to choose the relevancy. Rerun
              the command providing the specific test files (.py) to execute only
              those tests. Please don''t run on specific test cases to ensure efficiency."}'
            docstring: warns the user that pytest should be run on relevant test files
              only
            end_name: null
            name: warning_pytest
            signature: warning_pytest
          - arguments: null
            code: 'failed_test_message() {    echo "Reminder: When analyzing failed
              test cases, you must consider the following:"    echo ""    echo "First,
              analyze the failure message and the stack trace to understand what went
              wrong."    echo "Then, formulate a plan to fix each test case (or group
              of test cases) that failed."    echo ""}'
            docstring: strategies to handle failed test cases
            end_name: null
            name: failed_test_message
            signature: failed_test_message
          _subroutines: {}
          blocklist:
          - vim
          - vi
          - emacs
          - nano
          - nohup
          - git
          blocklist_error_template: Interactive operation '{name}' is not supported
            by this environment
          blocklist_standalone:
          - python
          - python3
          - ipython
          - bash
          - sh
          - exit
          - /bin/bash
          - /bin/sh
          - nohup
          - vi
          - vim
          - emacs
          - nano
          command_docs: |+
            open:
              docstring: opens the file at the given path in the editor. If line_number is provided, the window will be move to include that line
              signature: open <path> [<line_number>]
              arguments:
                - path (string) [required]: the path to the file to open
                - line_number (integer) [optional]: the line number to move the window to (if not provided, the window will start at the top of the file)

            goto:
              docstring: moves the window to show <line_number>
              signature: goto <line_number>
              arguments:
                - line_number (integer) [required]: the line number to move the window to

            scroll_down:
              docstring: moves the window down {WINDOW} lines
              signature: scroll_down

            scroll_up:
              docstring: moves the window down {WINDOW} lines
              signature: scroll_up

            create:
              docstring: creates and opens a new file with the given name
              signature: create <filename>
              arguments:
                - filename (string) [required]: the name of the file to create

            search_dir:
              docstring: searches for search_term in all files in dir. If dir is not provided, searches in the current directory
              signature: search_dir <search_term> [<dir>]
              arguments:
                - search_term (string) [required]: the term to search for
                - dir (string) [optional]: the directory to search in (if not provided, searches in the current directory)

            search_file:
              docstring: searches for search_term in file. If file is not provided, searches in the current open file
              signature: search_file <search_term> [<file>]
              arguments:
                - search_term (string) [required]: the term to search for
                - file (string) [optional]: the file to search in (if not provided, searches in the current open file)

            find_file:
              docstring: finds all files with the given name in dir. If dir is not provided, searches in the current directory
              signature: find_file <file_name> [<dir>]
              arguments:
                - file_name (string) [required]: the name of the file to search for
                - dir (string) [optional]: the directory to search in (if not provided, searches in the current directory)

            rover_search_file:
              docstring: search for a file named <file_name> in <project_path> by using the project-level search engine.
              signature: rover_search_file <project_path> <file_name>
              arguments:
                - project_path (string) [required]: This must be the path to the root of the project.
                - file_name (string) [required]: the name of file to be searched

            rover_search_class:
              docstring: search for a class named <class_name> in <project_path> by using the project-level search engine.
              signature: rover_search_class <project_path> <class_name>
              arguments:
                - project_path (string) [required]: This must be the path to the root of the project.
                - class_name (string) [required]: the name of class to be searched

            rover_search_method:
              docstring: search for a method named <method_name> in <project_path> by using the project-level search engine.
              signature: rover_search_method <project_path> <method_name>
              arguments:
                - project_path (string) [required]: This must be the path to the root of the project.
                - method_name (string) [required]: the name of method to be searched

            rover_search_code:
              docstring: search for a code snippet <code> in <project_path> by using the project-level search engine.
              signature: rover_search_code <project_path> <code>
              arguments:
                - project_path (string) [required]: This must be the path to the root of the project.
                - code (string) [required]: the code to be searched

            rover_search_code_in_file:
              docstring: search for a code snippet <code> in <file_name> from the directory <project_path> by using the project-level search engine.
              signature: rover_search_code_in_file <project_path> <file_name> <code>
              arguments:
                - project_path (string) [required]: This must be the path to the root of the project.
                - file_name (string) [required]: the name of the file in which the <code> is to be searched.
                - code (string) [required]: the code to be searched

            update_plan:
              docstring: The plan has been updated.
              signature: update_plan

            end_conversation:
              docstring: end the conversation
              signature: end_conversation

            warning_message_edit:
              docstring: display a warning message
              signature: warning_message_edit

            find_test_files:
              docstring: finds and lists all test files in the current or specified directory
              signature: find_test_files [<directory>]
              arguments:
                - directory (string) [optional]: the directory to search for test files (defaults to the current directory)

            warning_pytest:
              docstring: warns the user that pytest should be run on relevant test files only
              signature: warning_pytest

            failed_test_message:
              docstring: strategies to handle failed test cases
              signature: failed_test_message

          command_files:
          - /home/minkim/swe/testgen/swe_proj2/config/commands/defaults.sh
          - /home/minkim/swe/testgen/swe_proj2/config/commands/search.sh
          - /home/minkim/swe/testgen/swe_proj2/config/commands/_augmented_rover_search.py
          - /home/minkim/swe/testgen/swe_proj2/config/commands/rover_search.sh
          - /home/minkim/swe/testgen/swe_proj2/config/commands/chat_debugger.sh
          - /home/minkim/swe/testgen/swe_proj2/config/commands/unit_test.sh
          demonstration_template: |
            Here is a demonstration of how to correctly accomplish this task.
            It is included to show you how to correctly use the interface.
            You do not need to follow exactly what is done in the demonstration.
            --- DEMONSTRATION ---
            {demonstration}
            --- END OF DEMONSTRATION ---
          demonstrations:
          - /home/minkim/swe/testgen/swe_proj2/trajectories/demonstrations/multi_roles/chat_debugger_v7.traj
          env_variables:
            CURRENT_FILE: ''
            CURRENT_LINE: '0'
            OVERLAP: '2'
            SEARCH_FILES: ()
            SEARCH_INDEX: '0'
            SEARCH_RESULTS: ()
            WINDOW: '100'
          format_error_template: |
            Your output was not formatted correctly. You must always include one discussion and one command as part of your response. Make sure you do not have multiple discussion/command tags.
            Please make sure your output precisely matches the following format:
            DISCUSSION
            Discuss here with yourself about what your planning and what you're going to do in this step.

            ```
            command(s) that you're going to run
            ```
          history_processor: {}
          history_processor_args:
            max_tokens: 40000
            n: 5
          instance_template: "We're currently solving the following issue within our\
            \ repository. Here's the issue text:\nISSUE:\n{issue}\n\nINSTRUCTIONS:\n\
            You are the Debugger/Tester working in collaboration with a Programmer.\
            \ Your role is to guide the improvement of the v1 patch and the creation\
            \ or enhancement of an expanded_test.py file that expands test coverage\
            \ by referring to the existing tests in the repository, while still ensuring\
            \ the functionality mentioned in the issue.\n\nBegin your terminal session\
            \ in the root directory of the repository. Use bash commands or the special\
            \ interface as needed. ENTER ONE COMMAND AT A TIME and wait for a response\
            \ before proceeding. You can run scripts (e.g., `python <script_name>.py`)\
            \ but cannot use interactive session commands (e.g., vim).\n\n# \U0001F50D\
            \ FIXED TEST SESSION PLAN \U0001F50D\n\nAs the Debugger/Tester, you MUST\
            \ ALWAYS follow this EXACT plan after EACH interaction with the Programmer.\
            \ NO EXCEPTIONS.\n\n## \U0001F504 REPEAT THIS SEQUENCE AFTER EVERY PROGRAMMER\
            \ INTERACTION \U0001F504\n\n### \U0001F4CB LEVEL 1: Basic Reproduction\
            \ Test\n1. EXECUTE: `python reproduce.py`\n2. EVALUATE: Does the script\
            \ pass without reproducing the original issue?\n3. RECORD result\n\n###\
            \ \U0001F4CB LEVEL 2a: Run Pytest Integration Tests  \nRUN relevant unit\
            \ test file (disable warnings):\n\u2022 RELEVANT TEST FILE(s): [RELEVANT_TEST_FILES]\n\
            \u2022 EXECUTE: `pytest --disable-warnings <relevant_test_file.py>`\n\n\
            ### \U0001F4CB LEVEL 2b: expanded_test.py creation\n0. Gather project\
            \ context, such as related classes, methods, or code snippets, by utilizing\
            \ the following commands:\n  ```\n  # To search for a file, use the following\
            \ command:\n  rover_search_file <project_path> <file_name>\n  # To search\
            \ for a class, use the following command:\n  rover_search_class <project_path>\
            \ <class_name>\n  # To search for a method, use the following command:\n\
            \  rover_search_method <project_path> <method_name>\n  # To search for\
            \ a code snippet, use the following command:\n  rover_search_code <project_path>\
            \ <code>\n  # To search for a code snippet in a specific file, use the\
            \ following command:\n  rover_search_code_in_file <project_path> <file_name>\
            \ <code>\n  ```\n  Focus on understanding the classes, methods, and code\
            \ snippets that are related to the issue.\n  \n\nHere's a more concise\
            \ version of the prompt:\n\n1. Analyze relevant test file(s):\n  - Identify\
            \ testing framework, patterns, and conventions\n  - Note handling of edge\
            \ cases and errors\n\n2. Implement expanded_test.py:\n  - Use project's\
            \ testing framework and conventions\n  - Apply parameterization, isolation,\
            \ and fixtures as in existing tests\n  - Include edge cases and proper\
            \ assertions\n  - Adapt existing patterns to the new case being solved\n\
            \n3. Review implementation:\n  - Verify organization, isolation, and edge\
            \ case coverage\n  - Check adherence to existing test style and structure\n\
            \n4. Execute and evaluate:\n  - Run tests with project's standard runner\n\
            \  - Analyze coverage and performance\n\n5. Refine:\n  - Address shortcomings\
            \ and expand coverage\n  - Align with existing test patterns\n\n6. Final\
            \ verification:\n  - Rerun full test suite\n  - Confirm no regressions\
            \ and proper integration\n\n7. Record results and insights, noting alignment\
            \ with existing tests\n\nThis concise version maintains the focus on following\
            \ existing test protocols while adapting to the new case, but removes\
            \ redundancy and simplifies the instructions.\n\n## \U0001F6A8 AFTER COMPLETING\
            \ BOTH LEVELS \U0001F6A8\n\n1. COMPILE results and analysis\n2. a) if\
            \ the test results indicate that the core issue has not been fixed or\
            \ expanded coverage is insufficient, \n   EXECUTE: \n   ```\n   DISCUSSION\n\
            \   [Insert your compiled results and analysis here]\n   update_plan\n\
            \   ```\n\n   b) if the test results indicate that the core issue has\
            \ been fixed and expanded coverage is satisfactory, \n   EXECUTE: \n \
            \  ```\n   DISCUSSION\n   [Insert your compiled results and analysis here]\n\
            \   end_conversation\n   ```\n\n## \u26A0\uFE0F CRITICAL RULES \u26A0\uFE0F\
            \n- NEVER deviate from this plan\n- DO NOT write code yourself; guide\
            \ the Programmer in creating expanded_test.py\n- ALWAYS remind Programmer\
            \ of incomplete testing levels\n- USE `end_conversation` ONLY when:\n\
            \  a) BOTH LEVELS are passed\n  b) Tests REPEATEDLY fail after multiple\
            \ iterations\n\n## \U0001F501 REMEMBER \U0001F501\nYou MUST execute this\
            \ EXACT plan EVERY TIME. Your role is to GUIDE and TEST, not to IMPLEMENT.\n\
            \nIMPORTANT TIPS:\n1. Use `grep -r` or `find` commands to locate relevant\
            \ existing tests in the repository.\n2. When suggesting test scenarios\
            \ for expanded_test.py, consider edge cases and variations not covered\
            \ in reproduce.py.\n3. Encourage the Programmer to reuse test utility\
            \ functions or setup code from existing tests when creating expanded_test.py.\n\
            4. Ensure that expanded_test.py includes assertions that specifically\
            \ check for the issue mentioned in the bug report.\n5. If expanded_test.py\
            \ fails, work with the Programmer to refine it until it provides a reliable\
            \ expanded test.\n\nRemember: Your goal is to create a more comprehensive\
            \ test in expanded_test.py that goes beyond the original reproduce.py\
            \ while still focusing on the core issue.\n "
          multi_roles_transfer_template: |
            You are currently in a team organized by a manager, where each role has its own tasks. Everyone is working together to solve this issue. Here is some information about the team.
            History: {history_conclusion}

            Below are the conclusions obtained by colleague named {upstream_role} after some efforts: conclusions: {conclusion}

            CURRENT STATE
            (Open file: {open_file})
            (Current directory: {working_dir})
            bash-$
          next_step_no_output_template: |-
            Your command ran successfully and did not produce any output.
            (Open file: {open_file})
            (Current directory: {working_dir})
            bash-$
          next_step_template: |-
            {observation}
            (Open file: {open_file})
            (Current directory: {working_dir})
            bash-$
          parse_command: {}
          parse_function: {}
          planer_command:
            arguments: null
            code: null
            docstring: null
            end_name: end_of_plan
            name: plan
            signature: null
          put_demos_in_history: false
          state_command:
            arguments: null
            code: |
              state() {
                local working_dir="$PWD";
                if [ -z $CURRENT_FILE ]; then
                    echo '{"open_file": "n/a", "working_dir": "'$working_dir'"}';
                else
                    echo '{"open_file": "'$(realpath $CURRENT_FILE)'", "working_dir": "'$working_dir'"}';
                fi
              };
            docstring: null
            end_name: null
            name: state
            signature: null
          strategy_template: null
          submit_command: submit
          subroutine_types: []
          system_template: "SETTING: You are an autonomous intelligent agent leading\
            \ a hierarchical task structure to solve a coding issue. \nYour responsibility\
            \ is to provide high-level, strategic plans that can be broken down into\
            \ smaller tasks by the Programmer.\n\nYou will work directly in the command\
            \ line with a special interface.\nThe project contextual information contains\
            \ but not limited to, classes, methods, call chains, control and data\
            \ flows. Please do you best to collect enough information to propose a\
            \ good plan.\nThe special interface consists of a file editor that shows\
            \ you {WINDOW} lines of a file at a time.\nIn addition to typical bash\
            \ commands, you can also use the following commands to help you navigate.\n\
            \nCOMMANDS:\n{command_docs}\n\nRESPONSE FORMAT:\nYour shell prompt is\
            \ formatted as follows:\n(Open file: <path>) <cwd> $\n\nYou need to format\
            \ your output using two fields; discussion and command.\nYour output should\
            \ always include _one_ discussion and _one_ command field EXACTLY as in\
            \ the following example:\nDISCUSSION\nFirst I'll start by using ls to\
            \ see what files are in the current directory. Then maybe we can look\
            \ at some relevant files to see what they look like.\n```\nls -a\n```\n\
            \nYou should only include a *SINGLE* command in the command section and\
            \ then wait for a response from the shell before continuing with more\
            \ discussion and commands. Everything you include in the DISCUSSION section\
            \ will be saved for future reference.\nIf you'd like to issue two commands\
            \ at once, PLEASE DO NOT DO THAT! Please instead first submit just the\
            \ first command, and then after receiving a response you'll be able to\
            \ issue the second command. \nYou're free to use any other bash commands\
            \ you want (e.g. find, grep, cat, ls, cd) in addition to the special commands\
            \ listed above.\nHowever, the environment does NOT support interactive\
            \ session commands (e.g. vi, vim), so please do not invoke them.\n\nOnce\
            \ you make *NO PROGRESS* on current task, you should stop generating next\
            \ action. If the task is succeeded and the conversation can be concluded,\
            \ you should output `end_conversation` as the action.\n\nIMPORTANT TIPS:\
            \ DO NOT TRY TO SOLVE THE ISSUE YOURSELF. DELEGATE SUBTASKS TO THE PROGRAMMER."
          util_functions:
          - arguments: null
            code: '_print() {    local total_lines=$(awk ''END {print NR}'' $CURRENT_FILE)    echo
              "[File: $(realpath $CURRENT_FILE) ($total_lines lines total)]"    lines_above=$(jq
              -n "$CURRENT_LINE - $WINDOW/2" | jq ''[0, .] | max | floor'')    lines_below=$(jq
              -n "$total_lines - $CURRENT_LINE - $WINDOW/2" | jq ''[0, .] | max |
              round'')    if [ $lines_above -gt 0 ]; then        echo "($lines_above
              more lines above)"    fi    cat $CURRENT_FILE | grep -n $ | head -n
              $(jq -n "[$CURRENT_LINE + $WINDOW/2, $WINDOW/2] | max | floor") | tail
              -n $(jq -n "$WINDOW")    if [ $lines_below -gt 0 ]; then        echo
              "($lines_below more lines below)"    fi}'
            docstring: null
            end_name: null
            name: _print
            signature: _print
          - arguments: null
            code: _constrain_line() {    if [ -z "$CURRENT_FILE" ]    then        echo
              "No file open. Use the open command first."        return    fi    local
              max_line=$(awk 'END {print NR}' $CURRENT_FILE)    local half_window=$(jq
              -n "$WINDOW/2" | jq 'floor')    export CURRENT_LINE=$(jq -n "[$CURRENT_LINE,
              $max_line - $half_window] | min")    export CURRENT_LINE=$(jq -n "[$CURRENT_LINE,
              $half_window] | max")}
            docstring: null
            end_name: null
            name: _constrain_line
            signature: _constrain_line
        config_file: config/configs/roles/chat_debugger.yaml
        model:
          host_url: localhost:11434
          model_name: azure:gpt-4o-2024-05-13
          per_instance_cost_limit: 7.5
          replay_path: null
          temperature: 1.0
          top_p: 1.0
          total_cost_limit: 0.0
      agent_file: config/configs/roles/chat_debugger.yaml
      docstring: null
      end_name: null
      init_observation: null
      model:
        host_url: localhost:11434
        model_name: azure:gpt-4o-2024-05-13
        per_instance_cost_limit: 7.5
        replay_path: null
        temperature: 1.0
        top_p: 1.0
        total_cost_limit: 0.0
      name: Debugger
      return_type: traj
      signature: null
    - agent_args:
        config:
          _commands:
          - arguments:
              line_number:
                description: the line number to move the window to (if not provided,
                  the window will start at the top of the file)
                required: false
                type: integer
              path:
                description: the path to the file to open
                required: true
                type: string
            code: 'open() {    if [ -z "$1" ]    then        echo "Usage: open <file>"        return    fi    #
              Check if the second argument is provided    if [ -n "$2" ]; then        #
              Check if the provided argument is a valid number        if ! [[ $2 =~
              ^[0-9]+$ ]]; then            echo "Usage: open <file> [<line_number>]"            echo
              "Error: <line_number> must be a number"            return  # Exit if
              the line number is not valid        fi        local max_line=$(awk ''END
              {print NR}'' $1)        if [ $2 -gt $max_line ]; then            echo
              "Warning: <line_number> ($2) is greater than the number of lines in
              the file ($max_line)"            echo "Warning: Setting <line_number>
              to $max_line"            local line_number=$(jq -n "$max_line")  # Set
              line number to max if greater than max        elif [ $2 -lt 1 ]; then            echo
              "Warning: <line_number> ($2) is less than 1"            echo "Warning:
              Setting <line_number> to 1"            local line_number=$(jq -n "1")  #
              Set line number to 1 if less than 1        else            local OFFSET=$(jq
              -n "$WINDOW/6" | jq ''floor'')            local line_number=$(jq -n
              "[$2 + $WINDOW/2 - $OFFSET, 1] | max | floor")        fi    else        local
              line_number=$(jq -n "$WINDOW/2")  # Set default line number if not provided    fi    if
              [ -f "$1" ]; then        export CURRENT_FILE=$(realpath $1)        export
              CURRENT_LINE=$line_number        _constrain_line        _print    elif
              [ -d "$1" ]; then        echo "Error: $1 is a directory. You can only
              open files. Use cd or ls to navigate directories."    else        echo
              "File $1 not found"    fi}'
            docstring: opens the file at the given path in the editor. If line_number
              is provided, the window will be move to include that line
            end_name: null
            name: open
            signature: open <path> [<line_number>]
          - arguments:
              line_number:
                description: the line number to move the window to
                required: true
                type: integer
            code: 'goto() {    if [ $# -gt 1 ]; then        echo "goto allows only
              one line number at a time."        return    fi    if [ -z "$CURRENT_FILE"
              ]    then        echo "No file open. Use the open command first."        return    fi    if
              [ -z "$1" ]    then        echo "Usage: goto <line>"        return    fi    if
              ! [[ $1 =~ ^[0-9]+$ ]]    then        echo "Usage: goto <line>"        echo
              "Error: <line> must be a number"        return    fi    local max_line=$(awk
              ''END {print NR}'' $CURRENT_FILE)    if [ $1 -gt $max_line ]    then        echo
              "Error: <line> must be less than or equal to $max_line"        return    fi    local
              OFFSET=$(jq -n "$WINDOW/6" | jq ''floor'')    export CURRENT_LINE=$(jq
              -n "[$1 + $WINDOW/2 - $OFFSET, 1] | max | floor")    _constrain_line    _print}'
            docstring: moves the window to show <line_number>
            end_name: null
            name: goto
            signature: goto <line_number>
          - arguments: null
            code: scroll_down() {    if [ -z "$CURRENT_FILE" ]    then        echo
              "No file open. Use the open command first."        return    fi    export
              CURRENT_LINE=$(jq -n "$CURRENT_LINE + $WINDOW - $OVERLAP")    _constrain_line    _print}
            docstring: moves the window down {WINDOW} lines
            end_name: null
            name: scroll_down
            signature: scroll_down
          - arguments: null
            code: scroll_up() {    if [ -z "$CURRENT_FILE" ]    then        echo "No
              file open. Use the open command first."        return    fi    export
              CURRENT_LINE=$(jq -n "$CURRENT_LINE - $WINDOW + $OVERLAP")    _constrain_line    _print}
            docstring: moves the window down {WINDOW} lines
            end_name: null
            name: scroll_up
            signature: scroll_up
          - arguments:
              filename:
                description: the name of the file to create
                required: true
                type: string
            code: "create() {    if [ -z \"$1\" ]; then        echo \"Usage: create\
              \ <filename>\"        return    fi    # Check if the file already exists\
              \    if [ -e \"$1\" ]; then        echo \"Error: File '$1' already exists.\"\
              \t\topen \"$1\"        return    fi    # Create the file an empty new\
              \ line    printf \"\\n\" > \"$1\"    # Use the existing open command\
              \ to open the created file    open \"$1\"}"
            docstring: creates and opens a new file with the given name
            end_name: null
            name: create
            signature: create <filename>
          - arguments:
              dir:
                description: the directory to search in (if not provided, searches
                  in the current directory)
                required: false
                type: string
              search_term:
                description: the term to search for
                required: true
                type: string
            code: 'search_dir() {    if [ $# -eq 1 ]; then        local search_term="$1"        local
              dir="./"    elif [ $# -eq 2 ]; then        local search_term="$1"        if
              [ -d "$2" ]; then            local dir="$2"        else            echo
              "Directory $2 not found"            return        fi    else        echo
              "Usage: search_dir <search_term> [<dir>]"        return    fi    dir=$(realpath
              "$dir")    local matches=$(find "$dir" -type f ! -path ''*/.*'' -exec
              grep -nIH -- "$search_term" {} + | cut -d: -f1 | sort | uniq -c)    #
              if no matches, return    if [ -z "$matches" ]; then        echo "No
              matches found for \"$search_term\" in $dir"        return    fi    #
              Calculate total number of matches    local num_matches=$(echo "$matches"
              | awk ''{sum+=$1} END {print sum}'')    # calculate total number of
              files matched    local num_files=$(echo "$matches" | wc -l | awk ''{$1=$1;
              print $0}'')    # if num_files is > 100, print an error    if [ $num_files
              -gt 100 ]; then        echo "More than $num_files files matched for
              \"$search_term\" in $dir. Please narrow your search."        return    fi    echo
              "Found $num_matches matches for \"$search_term\" in $dir:"    echo "$matches"
              | awk ''{$2=$2; gsub(/^\.+\/+/, "./", $2); print $2 " ("$1" matches)"}''    echo
              "End of matches for \"$search_term\" in $dir"}'
            docstring: searches for search_term in all files in dir. If dir is not
              provided, searches in the current directory
            end_name: null
            name: search_dir
            signature: search_dir <search_term> [<dir>]
          - arguments:
              file:
                description: the file to search in (if not provided, searches in the
                  current open file)
                required: false
                type: string
              search_term:
                description: the term to search for
                required: true
                type: string
            code: 'search_file() {    # Check if the first argument is provided    if
              [ -z "$1" ]; then        echo "Usage: search_file <search_term> [<file>]"        return    fi    #
              Check if the second argument is provided    if [ -n "$2" ]; then        #
              Check if the provided argument is a valid file        if [ -f "$2" ];
              then            local file="$2"  # Set file if valid        else            echo
              "Usage: search_file <search_term> [<file>]"            echo "Error:
              File name $2 not found. Please provide a valid file name."            return  #
              Exit if the file is not valid        fi    else        # Check if a
              file is open        if [ -z "$CURRENT_FILE" ]; then            echo
              "No file open. Use the open command first."            return  # Exit
              if no file is open        fi        local file="$CURRENT_FILE"  # Set
              file to the current open file    fi    local search_term="$1"    file=$(realpath
              "$file")    # Use grep to directly get the desired formatted output    local
              matches=$(grep -nH -- "$search_term" "$file")    # Check if no matches
              were found    if [ -z "$matches" ]; then        echo "No matches found
              for \"$search_term\" in $file"        return    fi    # Calculate total
              number of matches    local num_matches=$(echo "$matches" | wc -l | awk
              ''{$1=$1; print $0}'')    # calculate total number of lines matched    local
              num_lines=$(echo "$matches" | cut -d: -f1 | sort | uniq | wc -l | awk
              ''{$1=$1; print $0}'')    # if num_lines is > 100, print an error    if
              [ $num_lines -gt 100 ]; then        echo "More than $num_lines lines
              matched for \"$search_term\" in $file. Please narrow your search."        return    fi    #
              Print the total number of matches and the matches themselves    echo
              "Found $num_matches matches for \"$search_term\" in $file:"    echo
              "$matches" | cut -d: -f1-2 | sort -u -t: -k2,2n | while IFS=: read -r
              filename line_number; do        echo "Line $line_number:$(sed -n "${line_number}p"
              "$file")"    done    echo "End of matches for \"$search_term\" in $file"}'
            docstring: searches for search_term in file. If file is not provided,
              searches in the current open file
            end_name: null
            name: search_file
            signature: search_file <search_term> [<file>]
          - arguments:
              dir:
                description: the directory to search in (if not provided, searches
                  in the current directory)
                required: false
                type: string
              file_name:
                description: the name of the file to search for
                required: true
                type: string
            code: 'find_file() {    if [ $# -eq 1 ]; then        local file_name="$1"        local
              dir="./"    elif [ $# -eq 2 ]; then        local file_name="$1"        if
              [ -d "$2" ]; then            local dir="$2"        else            echo
              "Directory $2 not found"            return        fi    else        echo
              "Usage: find_file <file_name> [<dir>]"        return    fi    dir=$(realpath
              "$dir")    local matches=$(find "$dir" -type f -name "$file_name")    #
              if no matches, return    if [ -z "$matches" ]; then        echo "No
              matches found for \"$file_name\" in $dir"        return    fi    # Calculate
              total number of matches    local num_matches=$(echo "$matches" | wc
              -l | awk ''{$1=$1; print $0}'')    echo "Found $num_matches matches
              for \"$file_name\" in $dir:"    echo "$matches" | awk ''{print $0}''}'
            docstring: finds all files with the given name in dir. If dir is not provided,
              searches in the current directory
            end_name: null
            name: find_file
            signature: find_file <file_name> [<dir>]
          - arguments:
              file_name:
                description: the name of file to be searched
                required: true
                type: string
              project_path:
                description: This must be the path to the root of the project.
                required: true
                type: string
            code: rover_search_file() {    python3 /root/commands/_augmented_rover_search.py
              rover_search_file "$1" "$2"}
            docstring: search for a file named <file_name> in <project_path> by using
              the project-level search engine.
            end_name: null
            name: rover_search_file
            signature: rover_search_file <project_path> <file_name>
          - arguments:
              class_name:
                description: the name of class to be searched
                required: true
                type: string
              project_path:
                description: This must be the path to the root of the project.
                required: true
                type: string
            code: rover_search_class() {    python3 /root/commands/_augmented_rover_search.py
              rover_search_class "$1" "$2"}
            docstring: search for a class named <class_name> in <project_path> by
              using the project-level search engine.
            end_name: null
            name: rover_search_class
            signature: rover_search_class <project_path> <class_name>
          - arguments:
              method_name:
                description: the name of method to be searched
                required: true
                type: string
              project_path:
                description: This must be the path to the root of the project.
                required: true
                type: string
            code: rover_search_method() {    python3 /root/commands/_augmented_rover_search.py
              rover_search_method "$1" "$2"}
            docstring: search for a method named <method_name> in <project_path> by
              using the project-level search engine.
            end_name: null
            name: rover_search_method
            signature: rover_search_method <project_path> <method_name>
          - arguments:
              code:
                description: the code to be searched
                required: true
                type: string
              project_path:
                description: This must be the path to the root of the project.
                required: true
                type: string
            code: rover_search_code() {    python3 /root/commands/_augmented_rover_search.py
              rover_search_code "$1" "$2"}
            docstring: search for a code snippet <code> in <project_path> by using
              the project-level search engine.
            end_name: null
            name: rover_search_code
            signature: rover_search_code <project_path> <code>
          - arguments:
              code:
                description: the code to be searched
                required: true
                type: string
              file_name:
                description: the name of the file in which the <code> is to be searched.
                required: true
                type: string
              project_path:
                description: This must be the path to the root of the project.
                required: true
                type: string
            code: rover_search_code_in_file() {    python3 /root/commands/_augmented_rover_search.py
              rover_search_code_in_file "$1" "$2" "$3"}
            docstring: search for a code snippet <code> in <file_name> from the directory
              <project_path> by using the project-level search engine.
            end_name: null
            name: rover_search_code_in_file
            signature: rover_search_code_in_file <project_path> <file_name> <code>
          - arguments:
              end_line:
                description: the line number to end the edit at (inclusive)
                required: true
                type: integer
              replacement_text:
                description: the text to replace the current selection with
                required: true
                type: string
              start_line:
                description: the line number to start the edit at
                required: true
                type: integer
            code: 'edit() {    if [ -z "$CURRENT_FILE" ]    then        echo ''No
              file open. Use the `open` command first.''        return    fi    local
              start_line="$(echo $1: | cut -d: -f1)"    local end_line="$(echo $1:
              | cut -d: -f2)"    if [ -z "$start_line" ] || [ -z "$end_line" ]    then        echo
              "Usage: edit <start_line>:<end_line>"        return    fi    local re=''^[0-9]+$''    if
              ! [[ $start_line =~ $re ]]; then        echo "Usage: edit <start_line>:<end_line>"        echo
              "Error: start_line must be a number"        return    fi    if ! [[
              $end_line =~ $re ]]; then        echo "Usage: edit <start_line>:<end_line>"        echo
              "Error: end_line must be a number"        return    fi    # Bash array
              starts at 0, so let''s adjust    local start_line=$((start_line - 1))    local
              end_line=$((end_line))    local line_count=0    local replacement=()    while
              IFS= read -r line    do        replacement+=("$line")        ((line_count++))    done    #
              Create a backup of the current file    cp "$CURRENT_FILE" "/root/$(basename
              "$CURRENT_FILE")_backup"    # Read the file line by line into an array    mapfile
              -t lines < "$CURRENT_FILE"    local new_lines=("${lines[@]:0:$start_line}"
              "${replacement[@]}" "${lines[@]:$((end_line))}")    # Write the new
              stuff directly back into the original file    printf "%s\n" "${new_lines[@]}"
              >| "$CURRENT_FILE"    # Run linter    if [[ $CURRENT_FILE == *.py ]];
              then        lint_output=$(flake8 --isolated --select=F821,F822,F831,E111,E112,E113,E999,E902
              "$CURRENT_FILE" 2>&1)    else        # do nothing        lint_output=""    fi    #
              if there is no output, then the file is good    if [ -z "$lint_output"
              ]; then        export CURRENT_LINE=$start_line        _constrain_line        _print        echo
              "File updated. Please review the changes and make sure they are correct
              (correct indentation, no duplicate lines, etc). Edit the file again
              if necessary."    else        echo "Your proposed edit has introduced
              new syntax error(s). Please read this error message carefully and then
              retry editing the file."        echo ""        echo "ERRORS:"        _split_string
              "$lint_output"        echo ""        # Save original values        original_current_line=$CURRENT_LINE        original_window=$WINDOW        #
              Update values        export CURRENT_LINE=$(( (line_count / 2) + start_line
              )) # Set to "center" of edit        export WINDOW=$((line_count + 10))
              # Show +/- 5 lines around edit        echo "This is how your edit would
              have looked if applied"        echo "-------------------------------------------------"        _constrain_line        _print        echo
              "-------------------------------------------------"        echo ""        #
              Restoring CURRENT_FILE to original contents.        cp "/root/$(basename
              "$CURRENT_FILE")_backup" "$CURRENT_FILE"        export CURRENT_LINE=$((
              ((end_line - start_line + 1) / 2) + start_line ))        export WINDOW=$((end_line
              - start_line + 10))        echo "This is the original code before your
              edit"        echo "-------------------------------------------------"        _constrain_line        _print        echo
              "-------------------------------------------------"        # Restore
              original values        export CURRENT_LINE=$original_current_line        export
              WINDOW=$original_window        echo "Your changes have NOT been applied.
              Please fix your edit command and try again."        echo "You either
              need to 1) Specify the correct start/end line arguments or 2) Correct
              your edit code."        echo "DO NOT re-run the same failed edit command.
              Running it again will lead to the same error."    fi    # Remove backup
              file    rm -f "/root/$(basename "$CURRENT_FILE")_backup"}'
            docstring: replaces lines <start_line> through <end_line> (inclusive)
              with the given text in the open file. The replacement text is terminated
              by a line with only end_of_edit on it. All of the <replacement text>
              will be entered, so make sure your indentation is formatted properly.
              Python files will be checked for syntax errors after the edit. If the
              system detects a syntax error, the edit will not be executed. Simply
              try to edit the file again, but make sure to read the error message
              and modify the edit command you issue accordingly. Issuing the same
              command a second time will just lead to the same error message again.
            end_name: end_of_edit
            name: edit
            signature: |-
              edit <start_line>:<end_line>
              <replacement_text>
              end_of_edit
          - arguments: null
            code: 'request_new_test_session() {    echo "Message to Debugger/Tester:
              Requesting a new independent test session."    echo    echo "ACTION
              ITEMS:"    echo "[1] INDEPENDENTLY run ''reproduce.py'' to verify the
              current state of the original issue."    echo "[2a] EXECUTE relevant
              pytest unit test file without assuming any previous results."      echo
              "[2b] REVIEW ''expanded_test.py'' to ensure it expands test coverage
              beyond ''reproduce.py''."    echo "[3] EXECUTE ''expanded_test.py''
              to verify expanded test coverage and functionality."    echo "If [1],
              [2a], [2b], and [3] are all verified successfully, submit the patch
              by running the end_conversation command. Otherwise, REPORT your findings
              based solely on this new test session."    echo    echo "IMPORTANT:"    echo
              "- Do NOT rely on any previous statements about test results."    echo
              "- Your role is to independently verify and report the current state
              of the system."    echo "- If ''expanded_test.py'' does not exist or
              is inadequate, work with the Programmer to create or improve it before
              proceeding."}'
            docstring: request the Debugger/Tester for an independent verification
              of the current state using both the original and expanded reproduction
              tests
            end_name: null
            name: request_new_test_session
            signature: request_new_test_session
          - arguments: null
            code: end_conversation() {    echo "Ending the conversation."}
            docstring: end the conversation
            end_name: null
            name: end_conversation
            signature: end_conversation
          - arguments: null
            code: 'warning_message_submit_patch() {    echo "WARNING: As editor you
              cannot directly submit the patch. Please run request_submit_patch command
              to request the tester to verify the patch and submit it."}'
            docstring: display a warning message
            end_name: null
            name: warning_message_submit_patch
            signature: warning_message_submit_patch
          - arguments: null
            code: request_submit_patch() {    echo "Requesting the Debugger to verify
              the patch and submit it."}
            docstring: request the tester to verify the patch and submit it
            end_name: null
            name: request_submit_patch
            signature: request_submit_patch
          - arguments: null
            code: 'warning_message_multiple_code_blocks() {    echo "Warning: I detected
              multiple code blocks in the previous message. Please only include one
              code block in your response, so that actions can be executed one by
              one."    echo ""    echo "Correct format (sequence of single actions,
              each with a thought):"    echo ""    echo "--- First Action ---"    echo
              ""    echo ""    echo "\`\`\`"    echo "edit file.py 10:15"    echo
              "def validate_user_input(input_string):"    echo "    return input_string.strip()
              != ''''"    echo "end_of_edit"    echo "\`\`\`"    echo ""    echo "After
              this edit is processed, proceed with the next action in a new message:"    echo
              ""    echo "--- Second Action ---"    echo ""    echo ""    echo "\`\`\`"    echo
              "edit file.py 20:25"    echo "def main():"    echo "    user_input =
              input(''Enter your name: '')"    echo "    if validate_user_input(user_input):"    echo
              "        print(f''Hello, {user_input}!'')"    echo "    else:"    echo
              "        print(''Invalid input'')"    echo "end_of_edit"    echo "\`\`\`"    echo
              ""    echo "Continue this pattern for each subsequent action, always
              including one thought and one code block per message."}'
            docstring: Display a warning message about multiple code blocks, including
              examples of correct formatting as a simple sequence
            end_name: null
            name: warning_message_multiple_code_blocks
            signature: warning_message_multiple_code_blocks
          - arguments: null
            code: 'warning_programmer_pytest() {    echo "Warning: As a Programmer,
              you cannot directly run pytest. If you feel that the code is ready,
              please run request_new_test_session command to request the Debugger
              to evaluate the code and submit the patch, along with a summary of the
              changes you made and what you are trying to test."}'
            docstring: warns the user that pytest should be run on relevant test files
              only
            end_name: null
            name: warning_programmer_pytest
            signature: warning_programmer_pytest
          - arguments: null
            code: 'warning_programmer_rm() {    echo "Warning: As a Programmer, you
              cannot directly remove the reproduction script. If you feel that the
              code is ready, please run request_new_test_session command to request
              the Debugger to evaluate the code and submit the patch."}'
            docstring: please don't remove reproduction script
            end_name: null
            name: warning_programmer_rm
            signature: warning_programmer_rm
          - arguments:
              directory:
                description: the directory to search for test files (defaults to the
                  current directory)
                required: false
                type: string
            code: 'find_test_files() {    local dir=${1:-.}        if [ ! -d "$dir"
              ]; then        echo "Error: $dir is not a valid directory."        return    fi        echo
              "Searching for test files in $dir..."        # Find files ending with
              _test.py or in a tests directory    local test_files=$(find "$dir" -type
              f \( -name ''*_test.py'' -o -path ''*/tests/*.py'' \))        if [ -z
              "$test_files" ]; then        echo "No test files found in $dir."    else        echo
              "Test files found:"        echo "$test_files"    fi}'
            docstring: finds and lists all test files in the current or specified
              directory
            end_name: null
            name: find_test_files
            signature: find_test_files [<directory>]
          - arguments: null
            code: 'warning_pytest() {    echo "Warning: Before running pytest, please
              make sure you have first identified the relevant test files (.py) for
              the issue. Run find_test_files and decide which test files are relevant.
              Please do not use keyword-based grep to choose the relevancy. Rerun
              the command providing the specific test files (.py) to execute only
              those tests. Please don''t run on specific test cases to ensure efficiency."}'
            docstring: warns the user that pytest should be run on relevant test files
              only
            end_name: null
            name: warning_pytest
            signature: warning_pytest
          - arguments: null
            code: 'failed_test_message() {    echo "Reminder: When analyzing failed
              test cases, you must consider the following:"    echo ""    echo "First,
              analyze the failure message and the stack trace to understand what went
              wrong."    echo "Then, formulate a plan to fix each test case (or group
              of test cases) that failed."    echo ""}'
            docstring: strategies to handle failed test cases
            end_name: null
            name: failed_test_message
            signature: failed_test_message
          _subroutines: {}
          blocklist:
          - vim
          - vi
          - emacs
          - nano
          - nohup
          - git
          blocklist_error_template: Interactive operation '{name}' is not supported
            by this environment
          blocklist_standalone:
          - python
          - python3
          - ipython
          - bash
          - sh
          - exit
          - /bin/bash
          - /bin/sh
          - nohup
          - vi
          - vim
          - emacs
          - nano
          command_docs: |+
            open:
              docstring: opens the file at the given path in the editor. If line_number is provided, the window will be move to include that line
              signature: open <path> [<line_number>]
              arguments:
                - path (string) [required]: the path to the file to open
                - line_number (integer) [optional]: the line number to move the window to (if not provided, the window will start at the top of the file)

            goto:
              docstring: moves the window to show <line_number>
              signature: goto <line_number>
              arguments:
                - line_number (integer) [required]: the line number to move the window to

            scroll_down:
              docstring: moves the window down {WINDOW} lines
              signature: scroll_down

            scroll_up:
              docstring: moves the window down {WINDOW} lines
              signature: scroll_up

            create:
              docstring: creates and opens a new file with the given name
              signature: create <filename>
              arguments:
                - filename (string) [required]: the name of the file to create

            search_dir:
              docstring: searches for search_term in all files in dir. If dir is not provided, searches in the current directory
              signature: search_dir <search_term> [<dir>]
              arguments:
                - search_term (string) [required]: the term to search for
                - dir (string) [optional]: the directory to search in (if not provided, searches in the current directory)

            search_file:
              docstring: searches for search_term in file. If file is not provided, searches in the current open file
              signature: search_file <search_term> [<file>]
              arguments:
                - search_term (string) [required]: the term to search for
                - file (string) [optional]: the file to search in (if not provided, searches in the current open file)

            find_file:
              docstring: finds all files with the given name in dir. If dir is not provided, searches in the current directory
              signature: find_file <file_name> [<dir>]
              arguments:
                - file_name (string) [required]: the name of the file to search for
                - dir (string) [optional]: the directory to search in (if not provided, searches in the current directory)

            rover_search_file:
              docstring: search for a file named <file_name> in <project_path> by using the project-level search engine.
              signature: rover_search_file <project_path> <file_name>
              arguments:
                - project_path (string) [required]: This must be the path to the root of the project.
                - file_name (string) [required]: the name of file to be searched

            rover_search_class:
              docstring: search for a class named <class_name> in <project_path> by using the project-level search engine.
              signature: rover_search_class <project_path> <class_name>
              arguments:
                - project_path (string) [required]: This must be the path to the root of the project.
                - class_name (string) [required]: the name of class to be searched

            rover_search_method:
              docstring: search for a method named <method_name> in <project_path> by using the project-level search engine.
              signature: rover_search_method <project_path> <method_name>
              arguments:
                - project_path (string) [required]: This must be the path to the root of the project.
                - method_name (string) [required]: the name of method to be searched

            rover_search_code:
              docstring: search for a code snippet <code> in <project_path> by using the project-level search engine.
              signature: rover_search_code <project_path> <code>
              arguments:
                - project_path (string) [required]: This must be the path to the root of the project.
                - code (string) [required]: the code to be searched

            rover_search_code_in_file:
              docstring: search for a code snippet <code> in <file_name> from the directory <project_path> by using the project-level search engine.
              signature: rover_search_code_in_file <project_path> <file_name> <code>
              arguments:
                - project_path (string) [required]: This must be the path to the root of the project.
                - file_name (string) [required]: the name of the file in which the <code> is to be searched.
                - code (string) [required]: the code to be searched

            edit:
              docstring: replaces lines <start_line> through <end_line> (inclusive) with the given text in the open file. The replacement text is terminated by a line with only end_of_edit on it. All of the <replacement text> will be entered, so make sure your indentation is formatted properly. Python files will be checked for syntax errors after the edit. If the system detects a syntax error, the edit will not be executed. Simply try to edit the file again, but make sure to read the error message and modify the edit command you issue accordingly. Issuing the same command a second time will just lead to the same error message again.
              signature: edit <start_line>:<end_line>
            <replacement_text>
            end_of_edit
              arguments:
                - start_line (integer) [required]: the line number to start the edit at
                - end_line (integer) [required]: the line number to end the edit at (inclusive)
                - replacement_text (string) [required]: the text to replace the current selection with

            request_new_test_session:
              docstring: request the Debugger/Tester for an independent verification of the current state using both the original and expanded reproduction tests
              signature: request_new_test_session

            end_conversation:
              docstring: end the conversation
              signature: end_conversation

            warning_message_submit_patch:
              docstring: display a warning message
              signature: warning_message_submit_patch

            request_submit_patch:
              docstring: request the tester to verify the patch and submit it
              signature: request_submit_patch

            warning_message_multiple_code_blocks:
              docstring: Display a warning message about multiple code blocks, including examples of correct formatting as a simple sequence
              signature: warning_message_multiple_code_blocks

            warning_programmer_pytest:
              docstring: warns the user that pytest should be run on relevant test files only
              signature: warning_programmer_pytest

            warning_programmer_rm:
              docstring: please don't remove reproduction script
              signature: warning_programmer_rm

            find_test_files:
              docstring: finds and lists all test files in the current or specified directory
              signature: find_test_files [<directory>]
              arguments:
                - directory (string) [optional]: the directory to search for test files (defaults to the current directory)

            warning_pytest:
              docstring: warns the user that pytest should be run on relevant test files only
              signature: warning_pytest

            failed_test_message:
              docstring: strategies to handle failed test cases
              signature: failed_test_message

          command_files:
          - /home/minkim/swe/testgen/swe_proj2/config/commands/defaults.sh
          - /home/minkim/swe/testgen/swe_proj2/config/commands/search.sh
          - /home/minkim/swe/testgen/swe_proj2/config/commands/_augmented_rover_search.py
          - /home/minkim/swe/testgen/swe_proj2/config/commands/rover_search.sh
          - /home/minkim/swe/testgen/swe_proj2/config/commands/edit_linting.sh
          - /home/minkim/swe/testgen/swe_proj2/config/commands/_split_string.py
          - /home/minkim/swe/testgen/swe_proj2/config/commands/chat_editor.sh
          - /home/minkim/swe/testgen/swe_proj2/config/commands/unit_test.sh
          demonstration_template: |
            Here is a demonstration of how to correctly accomplish this task.
            It is included to show you how to correctly use the interface.
            You do not need to follow exactly what is done in the demonstration.
            --- DEMONSTRATION ---
            {demonstration}
            --- END OF DEMONSTRATION ---
          demonstrations:
          - /home/minkim/swe/testgen/swe_proj2/trajectories/demonstrations/multi_roles/test_writer_fixture_v1.traj
          env_variables:
            CURRENT_FILE: ''
            CURRENT_LINE: '0'
            OVERLAP: '2'
            SEARCH_FILES: ()
            SEARCH_INDEX: '0'
            SEARCH_RESULTS: ()
            WINDOW: '100'
          format_error_template: |
            Your output was not formatted correctly. You must always include one discussion and one command as part of your response. Make sure you do not have multiple discussion/command tags.
            Please make sure your output precisely matches the following format:
            DISCUSSION
            Discuss here with yourself about what your planning and what you're going to do in this step.

            ```
            command(s) that you're going to run
            ```
          history_processor: {}
          history_processor_args: {}
          instance_template: "We're currently solving the following issue within our\
            \ repository. Here's the issue text:\nISSUE:\n {issue}\n\n\nINSTRUCTIONS:\n\
            \ Your task is to write tests that will help expose any incomplete or\
            \ insufficient solutions. You will be given source test files in one framework,\
            \ and your task is to migrate the tests to the new framework, Snowfort.\n\
            \n {task_instructions}\n \n 2. To understand Snowfort syntax and framework,\
            \ you can explore and study existing examples of written tests,\n for\
            \ example : Snowfort/tests/native_apps/provider_platform/trust/test_application_package_security_review_dropping.py\n\
            \n 3. Write down the detailed explanation of your understanding, including:\n\
            \ * The purpose and behavior of the function being tested\n * The structure\
            \ and content of the input fixtures (such as np.array)\n * The expected\
            \ outputs and how they relate to the inputs\n * The current issue and\
            \ how it affects the function's behavior\n * How the suggested fix would\
            \ change the function's behavior\n\n 4. After explaining your understanding,\
            \ create the new files necessary for the new tests.\n \n 7. Once you are\
            \ done, Submit the tests:\n ```\n submit\n ```\n Remember:\n\n YOU CAN\
            \ ONLY ENTER ONE COMMAND AT A TIME. Always wait for feedback after every\
            \ command.\n\n # Using Search Commands for Context\n\n - `rover_search_file\
            \ <project_path> <file_name>`\n - `rover_search_class <project_path> <class_name>`\n\
            \ - `rover_search_method <project_path> <method_name>`\n - `rover_search_code\
            \ <project_path> <code>`\n - `rover_search_code_in_file <project_path>\
            \ <file_name> <code>`\n\n Use these commands to understand related classes,\
            \ methods, and code snippets relevant to the issue at hand.\n\n # Navigation\
            \ and Editing\n\n - Use `goto <line_number>` for quick navigation\n -\
            \ Always check the currently open file and working directory\n - Pay attention\
            \ to indentation when editing\n - Double-check code after each edit command\n\
            \n Your task is complete when you've finished creating all the tests.\n\
            \n(Open file: {open_file})\n(Current directory: {working_dir})\nbash-$"
          multi_roles_transfer_template: null
          next_step_no_output_template: |-
            Your command ran successfully and did not produce any output.
            (Open file: {open_file})
            (Current directory: {working_dir})
            bash-$
          next_step_template: |-
            {observation}
            (Open file: {open_file})
            (Current directory: {working_dir})
            bash-$
          parse_command: {}
          parse_function: {}
          planer_command:
            arguments: null
            code: null
            docstring: null
            end_name: end_of_plan
            name: plan
            signature: null
          put_demos_in_history: false
          state_command:
            arguments: null
            code: |
              state() {
                local working_dir="$PWD";
                if [ -z $CURRENT_FILE ]; then
                    echo '{"open_file": "n/a", "working_dir": "'$working_dir'"}';
                else
                    echo '{"open_file": "'$(realpath $CURRENT_FILE)'", "working_dir": "'$working_dir'"}';
                fi
              };
            docstring: null
            end_name: null
            name: state
            signature: null
          strategy_template: null
          submit_command: submit
          subroutine_types: []
          system_template: |-
            SETTING: You are an autonomous programmer, and you're working directly in the command line with a special interface.

            The special interface consists of a file editor that shows you {WINDOW} lines of a file at a time.
            In addition to typical bash commands, you can also use the following commands to help you navigate and edit files.

            COMMANDS:
            {command_docs}

            Please note that THE EDIT COMMAND REQUIRES PROPER INDENTATION.
            If you'd like to add the line '        print(x)' you must fully write that out, with all those spaces before the code! Indentation is important and code that is not indented correctly will fail and require fixing before it can be run.

            RESPONSE FORMAT:
            Your shell prompt is formatted as follows:
            (Open file: <path>) <cwd> $

            You need to format your output using two fields; discussion and command.
            Your output should always include _one_ discussion and _one_ command field EXACTLY as in the following example:
            DISCUSSION
            First I'll start by using ls to see what files are in the current directory. Then maybe we can look at some relevant files to see what they look like.
            ```
            ls -a
            ```

            You should only include a *SINGLE* command in the command section and then wait for a response from the shell before continuing with more discussion and commands. Everything you include in the DISCUSSION section will be saved for future reference.
            If you'd like to issue two commands at once, PLEASE DO NOT DO THAT! Please instead first submit just the first command, and then after receiving a response you'll be able to issue the second command.
            You're free to use any other bash commands you want (e.g. find, grep, cat, ls, cd) in addition to the special commands listed above.
            However, the environment does NOT support interactive session commands (e.g. python, vim), so please do not invoke them.
          util_functions:
          - arguments: null
            code: '_print() {    local total_lines=$(awk ''END {print NR}'' $CURRENT_FILE)    echo
              "[File: $(realpath $CURRENT_FILE) ($total_lines lines total)]"    lines_above=$(jq
              -n "$CURRENT_LINE - $WINDOW/2" | jq ''[0, .] | max | floor'')    lines_below=$(jq
              -n "$total_lines - $CURRENT_LINE - $WINDOW/2" | jq ''[0, .] | max |
              round'')    if [ $lines_above -gt 0 ]; then        echo "($lines_above
              more lines above)"    fi    cat $CURRENT_FILE | grep -n $ | head -n
              $(jq -n "[$CURRENT_LINE + $WINDOW/2, $WINDOW/2] | max | floor") | tail
              -n $(jq -n "$WINDOW")    if [ $lines_below -gt 0 ]; then        echo
              "($lines_below more lines below)"    fi}'
            docstring: null
            end_name: null
            name: _print
            signature: _print
          - arguments: null
            code: _constrain_line() {    if [ -z "$CURRENT_FILE" ]    then        echo
              "No file open. Use the open command first."        return    fi    local
              max_line=$(awk 'END {print NR}' $CURRENT_FILE)    local half_window=$(jq
              -n "$WINDOW/2" | jq 'floor')    export CURRENT_LINE=$(jq -n "[$CURRENT_LINE,
              $max_line - $half_window] | min")    export CURRENT_LINE=$(jq -n "[$CURRENT_LINE,
              $half_window] | max")}
            docstring: null
            end_name: null
            name: _constrain_line
            signature: _constrain_line
        config_file: config/configs/roles/chat_editor.yaml
        model:
          host_url: localhost:11434
          model_name: azure:gpt-4o-2024-05-13
          per_instance_cost_limit: 7.5
          replay_path: null
          temperature: 1.0
          top_p: 1.0
          total_cost_limit: 0.0
      agent_file: config/configs/roles/chat_editor.yaml
      docstring: null
      end_name: null
      init_observation: null
      model:
        host_url: localhost:11434
        model_name: azure:gpt-4o-2024-05-13
        per_instance_cost_limit: 7.5
        replay_path: null
        temperature: 1.0
        top_p: 1.0
        total_cost_limit: 0.0
      name: Programmer
      return_type: traj
      signature: null
    - agent_args:
        config:
          _commands:
          - arguments:
              line_number:
                description: the line number to move the window to (if not provided,
                  the window will start at the top of the file)
                required: false
                type: integer
              path:
                description: the path to the file to open
                required: true
                type: string
            code: 'open() {    if [ -z "$1" ]    then        echo "Usage: open <file>"        return    fi    #
              Check if the second argument is provided    if [ -n "$2" ]; then        #
              Check if the provided argument is a valid number        if ! [[ $2 =~
              ^[0-9]+$ ]]; then            echo "Usage: open <file> [<line_number>]"            echo
              "Error: <line_number> must be a number"            return  # Exit if
              the line number is not valid        fi        local max_line=$(awk ''END
              {print NR}'' $1)        if [ $2 -gt $max_line ]; then            echo
              "Warning: <line_number> ($2) is greater than the number of lines in
              the file ($max_line)"            echo "Warning: Setting <line_number>
              to $max_line"            local line_number=$(jq -n "$max_line")  # Set
              line number to max if greater than max        elif [ $2 -lt 1 ]; then            echo
              "Warning: <line_number> ($2) is less than 1"            echo "Warning:
              Setting <line_number> to 1"            local line_number=$(jq -n "1")  #
              Set line number to 1 if less than 1        else            local OFFSET=$(jq
              -n "$WINDOW/6" | jq ''floor'')            local line_number=$(jq -n
              "[$2 + $WINDOW/2 - $OFFSET, 1] | max | floor")        fi    else        local
              line_number=$(jq -n "$WINDOW/2")  # Set default line number if not provided    fi    if
              [ -f "$1" ]; then        export CURRENT_FILE=$(realpath $1)        export
              CURRENT_LINE=$line_number        _constrain_line        _print    elif
              [ -d "$1" ]; then        echo "Error: $1 is a directory. You can only
              open files. Use cd or ls to navigate directories."    else        echo
              "File $1 not found"    fi}'
            docstring: opens the file at the given path in the editor. If line_number
              is provided, the window will be move to include that line
            end_name: null
            name: open
            signature: open <path> [<line_number>]
          - arguments:
              line_number:
                description: the line number to move the window to
                required: true
                type: integer
            code: 'goto() {    if [ $# -gt 1 ]; then        echo "goto allows only
              one line number at a time."        return    fi    if [ -z "$CURRENT_FILE"
              ]    then        echo "No file open. Use the open command first."        return    fi    if
              [ -z "$1" ]    then        echo "Usage: goto <line>"        return    fi    if
              ! [[ $1 =~ ^[0-9]+$ ]]    then        echo "Usage: goto <line>"        echo
              "Error: <line> must be a number"        return    fi    local max_line=$(awk
              ''END {print NR}'' $CURRENT_FILE)    if [ $1 -gt $max_line ]    then        echo
              "Error: <line> must be less than or equal to $max_line"        return    fi    local
              OFFSET=$(jq -n "$WINDOW/6" | jq ''floor'')    export CURRENT_LINE=$(jq
              -n "[$1 + $WINDOW/2 - $OFFSET, 1] | max | floor")    _constrain_line    _print}'
            docstring: moves the window to show <line_number>
            end_name: null
            name: goto
            signature: goto <line_number>
          - arguments: null
            code: scroll_down() {    if [ -z "$CURRENT_FILE" ]    then        echo
              "No file open. Use the open command first."        return    fi    export
              CURRENT_LINE=$(jq -n "$CURRENT_LINE + $WINDOW - $OVERLAP")    _constrain_line    _print}
            docstring: moves the window down {WINDOW} lines
            end_name: null
            name: scroll_down
            signature: scroll_down
          - arguments: null
            code: scroll_up() {    if [ -z "$CURRENT_FILE" ]    then        echo "No
              file open. Use the open command first."        return    fi    export
              CURRENT_LINE=$(jq -n "$CURRENT_LINE - $WINDOW + $OVERLAP")    _constrain_line    _print}
            docstring: moves the window down {WINDOW} lines
            end_name: null
            name: scroll_up
            signature: scroll_up
          - arguments:
              filename:
                description: the name of the file to create
                required: true
                type: string
            code: "create() {    if [ -z \"$1\" ]; then        echo \"Usage: create\
              \ <filename>\"        return    fi    # Check if the file already exists\
              \    if [ -e \"$1\" ]; then        echo \"Error: File '$1' already exists.\"\
              \t\topen \"$1\"        return    fi    # Create the file an empty new\
              \ line    printf \"\\n\" > \"$1\"    # Use the existing open command\
              \ to open the created file    open \"$1\"}"
            docstring: creates and opens a new file with the given name
            end_name: null
            name: create
            signature: create <filename>
          - arguments:
              dir:
                description: the directory to search in (if not provided, searches
                  in the current directory)
                required: false
                type: string
              search_term:
                description: the term to search for
                required: true
                type: string
            code: 'search_dir() {    if [ $# -eq 1 ]; then        local search_term="$1"        local
              dir="./"    elif [ $# -eq 2 ]; then        local search_term="$1"        if
              [ -d "$2" ]; then            local dir="$2"        else            echo
              "Directory $2 not found"            return        fi    else        echo
              "Usage: search_dir <search_term> [<dir>]"        return    fi    dir=$(realpath
              "$dir")    local matches=$(find "$dir" -type f ! -path ''*/.*'' -exec
              grep -nIH -- "$search_term" {} + | cut -d: -f1 | sort | uniq -c)    #
              if no matches, return    if [ -z "$matches" ]; then        echo "No
              matches found for \"$search_term\" in $dir"        return    fi    #
              Calculate total number of matches    local num_matches=$(echo "$matches"
              | awk ''{sum+=$1} END {print sum}'')    # calculate total number of
              files matched    local num_files=$(echo "$matches" | wc -l | awk ''{$1=$1;
              print $0}'')    # if num_files is > 100, print an error    if [ $num_files
              -gt 100 ]; then        echo "More than $num_files files matched for
              \"$search_term\" in $dir. Please narrow your search."        return    fi    echo
              "Found $num_matches matches for \"$search_term\" in $dir:"    echo "$matches"
              | awk ''{$2=$2; gsub(/^\.+\/+/, "./", $2); print $2 " ("$1" matches)"}''    echo
              "End of matches for \"$search_term\" in $dir"}'
            docstring: searches for search_term in all files in dir. If dir is not
              provided, searches in the current directory
            end_name: null
            name: search_dir
            signature: search_dir <search_term> [<dir>]
          - arguments:
              file:
                description: the file to search in (if not provided, searches in the
                  current open file)
                required: false
                type: string
              search_term:
                description: the term to search for
                required: true
                type: string
            code: 'search_file() {    # Check if the first argument is provided    if
              [ -z "$1" ]; then        echo "Usage: search_file <search_term> [<file>]"        return    fi    #
              Check if the second argument is provided    if [ -n "$2" ]; then        #
              Check if the provided argument is a valid file        if [ -f "$2" ];
              then            local file="$2"  # Set file if valid        else            echo
              "Usage: search_file <search_term> [<file>]"            echo "Error:
              File name $2 not found. Please provide a valid file name."            return  #
              Exit if the file is not valid        fi    else        # Check if a
              file is open        if [ -z "$CURRENT_FILE" ]; then            echo
              "No file open. Use the open command first."            return  # Exit
              if no file is open        fi        local file="$CURRENT_FILE"  # Set
              file to the current open file    fi    local search_term="$1"    file=$(realpath
              "$file")    # Use grep to directly get the desired formatted output    local
              matches=$(grep -nH -- "$search_term" "$file")    # Check if no matches
              were found    if [ -z "$matches" ]; then        echo "No matches found
              for \"$search_term\" in $file"        return    fi    # Calculate total
              number of matches    local num_matches=$(echo "$matches" | wc -l | awk
              ''{$1=$1; print $0}'')    # calculate total number of lines matched    local
              num_lines=$(echo "$matches" | cut -d: -f1 | sort | uniq | wc -l | awk
              ''{$1=$1; print $0}'')    # if num_lines is > 100, print an error    if
              [ $num_lines -gt 100 ]; then        echo "More than $num_lines lines
              matched for \"$search_term\" in $file. Please narrow your search."        return    fi    #
              Print the total number of matches and the matches themselves    echo
              "Found $num_matches matches for \"$search_term\" in $file:"    echo
              "$matches" | cut -d: -f1-2 | sort -u -t: -k2,2n | while IFS=: read -r
              filename line_number; do        echo "Line $line_number:$(sed -n "${line_number}p"
              "$file")"    done    echo "End of matches for \"$search_term\" in $file"}'
            docstring: searches for search_term in file. If file is not provided,
              searches in the current open file
            end_name: null
            name: search_file
            signature: search_file <search_term> [<file>]
          - arguments:
              dir:
                description: the directory to search in (if not provided, searches
                  in the current directory)
                required: false
                type: string
              file_name:
                description: the name of the file to search for
                required: true
                type: string
            code: 'find_file() {    if [ $# -eq 1 ]; then        local file_name="$1"        local
              dir="./"    elif [ $# -eq 2 ]; then        local file_name="$1"        if
              [ -d "$2" ]; then            local dir="$2"        else            echo
              "Directory $2 not found"            return        fi    else        echo
              "Usage: find_file <file_name> [<dir>]"        return    fi    dir=$(realpath
              "$dir")    local matches=$(find "$dir" -type f -name "$file_name")    #
              if no matches, return    if [ -z "$matches" ]; then        echo "No
              matches found for \"$file_name\" in $dir"        return    fi    # Calculate
              total number of matches    local num_matches=$(echo "$matches" | wc
              -l | awk ''{$1=$1; print $0}'')    echo "Found $num_matches matches
              for \"$file_name\" in $dir:"    echo "$matches" | awk ''{print $0}''}'
            docstring: finds all files with the given name in dir. If dir is not provided,
              searches in the current directory
            end_name: null
            name: find_file
            signature: find_file <file_name> [<dir>]
          - arguments:
              end_line:
                description: the line number to end the edit at (inclusive)
                required: true
                type: integer
              replacement_text:
                description: the text to replace the current selection with
                required: true
                type: string
              start_line:
                description: the line number to start the edit at
                required: true
                type: integer
            code: 'edit() {    if [ -z "$CURRENT_FILE" ]    then        echo ''No
              file open. Use the `open` command first.''        return    fi    local
              start_line="$(echo $1: | cut -d: -f1)"    local end_line="$(echo $1:
              | cut -d: -f2)"    if [ -z "$start_line" ] || [ -z "$end_line" ]    then        echo
              "Usage: edit <start_line>:<end_line>"        return    fi    local re=''^[0-9]+$''    if
              ! [[ $start_line =~ $re ]]; then        echo "Usage: edit <start_line>:<end_line>"        echo
              "Error: start_line must be a number"        return    fi    if ! [[
              $end_line =~ $re ]]; then        echo "Usage: edit <start_line>:<end_line>"        echo
              "Error: end_line must be a number"        return    fi    # Bash array
              starts at 0, so let''s adjust    local start_line=$((start_line - 1))    local
              end_line=$((end_line))    local line_count=0    local replacement=()    while
              IFS= read -r line    do        replacement+=("$line")        ((line_count++))    done    #
              Create a backup of the current file    cp "$CURRENT_FILE" "/root/$(basename
              "$CURRENT_FILE")_backup"    # Read the file line by line into an array    mapfile
              -t lines < "$CURRENT_FILE"    local new_lines=("${lines[@]:0:$start_line}"
              "${replacement[@]}" "${lines[@]:$((end_line))}")    # Write the new
              stuff directly back into the original file    printf "%s\n" "${new_lines[@]}"
              >| "$CURRENT_FILE"    # Run linter    if [[ $CURRENT_FILE == *.py ]];
              then        lint_output=$(flake8 --isolated --select=F821,F822,F831,E111,E112,E113,E999,E902
              "$CURRENT_FILE" 2>&1)    else        # do nothing        lint_output=""    fi    #
              if there is no output, then the file is good    if [ -z "$lint_output"
              ]; then        export CURRENT_LINE=$start_line        _constrain_line        _print        echo
              "File updated. Please review the changes and make sure they are correct
              (correct indentation, no duplicate lines, etc). Edit the file again
              if necessary."    else        echo "Your proposed edit has introduced
              new syntax error(s). Please read this error message carefully and then
              retry editing the file."        echo ""        echo "ERRORS:"        _split_string
              "$lint_output"        echo ""        # Save original values        original_current_line=$CURRENT_LINE        original_window=$WINDOW        #
              Update values        export CURRENT_LINE=$(( (line_count / 2) + start_line
              )) # Set to "center" of edit        export WINDOW=$((line_count + 10))
              # Show +/- 5 lines around edit        echo "This is how your edit would
              have looked if applied"        echo "-------------------------------------------------"        _constrain_line        _print        echo
              "-------------------------------------------------"        echo ""        #
              Restoring CURRENT_FILE to original contents.        cp "/root/$(basename
              "$CURRENT_FILE")_backup" "$CURRENT_FILE"        export CURRENT_LINE=$((
              ((end_line - start_line + 1) / 2) + start_line ))        export WINDOW=$((end_line
              - start_line + 10))        echo "This is the original code before your
              edit"        echo "-------------------------------------------------"        _constrain_line        _print        echo
              "-------------------------------------------------"        # Restore
              original values        export CURRENT_LINE=$original_current_line        export
              WINDOW=$original_window        echo "Your changes have NOT been applied.
              Please fix your edit command and try again."        echo "You either
              need to 1) Specify the correct start/end line arguments or 2) Correct
              your edit code."        echo "DO NOT re-run the same failed edit command.
              Running it again will lead to the same error."    fi    # Remove backup
              file    rm -f "/root/$(basename "$CURRENT_FILE")_backup"}'
            docstring: replaces lines <start_line> through <end_line> (inclusive)
              with the given text in the open file. The replacement text is terminated
              by a line with only end_of_edit on it. All of the <replacement text>
              will be entered, so make sure your indentation is formatted properly.
              Python files will be checked for syntax errors after the edit. If the
              system detects a syntax error, the edit will not be executed. Simply
              try to edit the file again, but make sure to read the error message
              and modify the edit command you issue accordingly. Issuing the same
              command a second time will just lead to the same error message again.
            end_name: end_of_edit
            name: edit
            signature: |-
              edit <start_line>:<end_line>
              <replacement_text>
              end_of_edit
          _subroutines: {}
          blocklist:
          - vim
          - vi
          - emacs
          - nano
          - nohup
          - git
          blocklist_error_template: Interactive operation '{name}' is not supported
            by this environment
          blocklist_standalone:
          - python
          - python3
          - ipython
          - bash
          - sh
          - exit
          - /bin/bash
          - /bin/sh
          - nohup
          - vi
          - vim
          - emacs
          - nano
          command_docs: |+
            open:
              docstring: opens the file at the given path in the editor. If line_number is provided, the window will be move to include that line
              signature: open <path> [<line_number>]
              arguments:
                - path (string) [required]: the path to the file to open
                - line_number (integer) [optional]: the line number to move the window to (if not provided, the window will start at the top of the file)

            goto:
              docstring: moves the window to show <line_number>
              signature: goto <line_number>
              arguments:
                - line_number (integer) [required]: the line number to move the window to

            scroll_down:
              docstring: moves the window down {WINDOW} lines
              signature: scroll_down

            scroll_up:
              docstring: moves the window down {WINDOW} lines
              signature: scroll_up

            create:
              docstring: creates and opens a new file with the given name
              signature: create <filename>
              arguments:
                - filename (string) [required]: the name of the file to create

            search_dir:
              docstring: searches for search_term in all files in dir. If dir is not provided, searches in the current directory
              signature: search_dir <search_term> [<dir>]
              arguments:
                - search_term (string) [required]: the term to search for
                - dir (string) [optional]: the directory to search in (if not provided, searches in the current directory)

            search_file:
              docstring: searches for search_term in file. If file is not provided, searches in the current open file
              signature: search_file <search_term> [<file>]
              arguments:
                - search_term (string) [required]: the term to search for
                - file (string) [optional]: the file to search in (if not provided, searches in the current open file)

            find_file:
              docstring: finds all files with the given name in dir. If dir is not provided, searches in the current directory
              signature: find_file <file_name> [<dir>]
              arguments:
                - file_name (string) [required]: the name of the file to search for
                - dir (string) [optional]: the directory to search in (if not provided, searches in the current directory)

            edit:
              docstring: replaces lines <start_line> through <end_line> (inclusive) with the given text in the open file. The replacement text is terminated by a line with only end_of_edit on it. All of the <replacement text> will be entered, so make sure your indentation is formatted properly. Python files will be checked for syntax errors after the edit. If the system detects a syntax error, the edit will not be executed. Simply try to edit the file again, but make sure to read the error message and modify the edit command you issue accordingly. Issuing the same command a second time will just lead to the same error message again.
              signature: edit <start_line>:<end_line>
            <replacement_text>
            end_of_edit
              arguments:
                - start_line (integer) [required]: the line number to start the edit at
                - end_line (integer) [required]: the line number to end the edit at (inclusive)
                - replacement_text (string) [required]: the text to replace the current selection with

          command_files:
          - /home/minkim/swe/testgen/swe_proj2/config/commands/defaults.sh
          - /home/minkim/swe/testgen/swe_proj2/config/commands/search.sh
          - /home/minkim/swe/testgen/swe_proj2/config/commands/edit_linting.sh
          - /home/minkim/swe/testgen/swe_proj2/config/commands/_split_string.py
          demonstration_template: |
            Here is a demonstration of how to correctly accomplish this task.
            It is included to show you how to correctly use the interface.
            You do not need to follow exactly what is done in the demonstration.
            --- DEMONSTRATION ---
            {demonstration}
            --- END OF DEMONSTRATION ---
          demonstrations: []
          env_variables:
            CURRENT_FILE: ''
            CURRENT_LINE: '0'
            OVERLAP: '2'
            SEARCH_FILES: ()
            SEARCH_INDEX: '0'
            SEARCH_RESULTS: ()
            WINDOW: '100'
          format_error_template: |
            Your output was not formatted correctly. You must always include one discussion and one command as part of your response. Make sure you do not have multiple discussion/command tags.
            Please make sure your output precisely matches the following format:
            DISCUSSION
            Discuss here with yourself about what your planning and what you're going to do in this step.

            ```
            command(s) that you're going to run
            ```
          history_processor: {}
          history_processor_args:
            n: 5
          instance_template: "We're currently solving the following issue within our\
            \ repository. Here's the issue text:\nISSUE:\n{issue}\n\nINSTRUCTIONS:\n\
            Now, you're going to solve this issue on your own from the perspective\
            \ of a tester. Your terminal session has started and you're in the repository's\
            \ root directory. You can use any bash commands or the special interface\
            \ to help you. \nRemember, YOU CAN ONLY ENTER ONE COMMAND AT A TIME. You\
            \ should always wait for feedback after every command.\n\nIMPORTANT TIPS:\n\
            1. Besides general commands, programmers also have special commands at\
            \ their disposal. Carefully consider and select the appropriate command\
            \ to use;\n\n2. Based on your attempts to reproduce and solve the issue,\
            \ it is necessary to run <reproduce.py>.\n  \n3. When you execute the\
            \ edit command multiple times to modify the same file and encounter syntax\
            \ errors, such as indentation issues, you should consider opening the\
            \ file to review its content again, and then make modifications based\
            \ on your previous analysis.\n  \n4. If you are uncertain about the specific\
            \ line number when searching for a snippet of code, a class, or a method\
            \ within a file, prioritize using the `grep -nr <code/class/method>` command\
            \ to retrieve the approximate location. Then, after opening the file,\
            \ use the `goto` command to navigate to the snippet, preventing excessive\
            \ use of the `scroll down` command. If the `grep -nr` command does not\
            \ retrieve any relevant content, consider using the `scroll down` or `scroll\
            \ up` commands to search for the code after opening the file.\n  \n5.\
            \ If you run a command and it doesn't work, try running a different command.\
            \ A command that did not work once will not work the second time unless\
            \ you modify it!\n\n6. If you open a file and need to get to an area around\
            \ a specific line that is not in the first 100 lines, say line 583, don't\
            \ just use the scroll_down command multiple times. Instead, use the goto\
            \ 583 command. It's much quicker. \n     \n7. Always make sure to look\
            \ at the currently open file and the current working directory (which\
            \ appears right after the currently open file). The currently open file\
            \ might be in a different directory than the working directory! Note that\
            \ some commands, such as 'create', open files, so they might change the\
            \ current  open file.\n\n8. When editing files, it is easy to accidentally\
            \ specify a wrong line number or to write code with incorrect indentation.\
            \ Always check the code after you issue an edit to make sure that it reflects\
            \ what you wanted to accomplish. If it didn't, issue another command to\
            \ fix it.\n  \n9. You can directly execute the <reproduce.py> file using\
            \ `python` to check whether the issue has been resolved.\n  \n10. Only\
            \ return \"succeed\" command when the current issue is truly resolved.\
            \ If the current task still cannot be completed after trying many different\
            \ solutions, please return \"fail\" command."
          multi_roles_transfer_template: |
            You are currently in a team organized by a manager, where each role has its own tasks. Everyone is working together to solve this issue. Here is some information about the team.
            {observation}

            CURRENT STATE
            (Open file: {open_file})
            (Current directory: {working_dir})
            bash-$
          next_step_no_output_template: |-
            Your command ran successfully and did not produce any output.
            (Open file: {open_file})
            (Current directory: {working_dir})
            bash-$
          next_step_template: |-
            {observation}
            (Open file: {open_file})
            (Current directory: {working_dir})
            bash-$
          parse_command: {}
          parse_function: {}
          planer_command:
            arguments: null
            code: null
            docstring: null
            end_name: end_of_plan
            name: plan
            signature: null
          put_demos_in_history: false
          state_command:
            arguments: null
            code: |
              state() {
                local working_dir="$PWD";
                if [ -z $CURRENT_FILE ]; then
                    echo '{"open_file": "n/a", "working_dir": "'$working_dir'"}';
                else
                    echo '{"open_file": "'$(realpath $CURRENT_FILE)'", "working_dir": "'$working_dir'"}';
                fi
              };
            docstring: null
            end_name: null
            name: state
            signature: null
          strategy_template: null
          submit_command: submit
          subroutine_types: []
          system_template: "You are an autonomous tester working directly in the command\
            \ line with a special interface designed for efficient and effective software\
            \ testing.\n\nIn addition to typical bash commands, you can also use the\
            \ following *general* and *tester-specific*  commands to help you run\
            \ test cases.\n\nCOMMANDS:\n{command_docs}\n\nPlease note that THE EDIT\
            \ COMMAND REQUIRES PROPER INDENTATION. \nIf you'd like to add the line\
            \ '        print(x)' you must fully write that out, with all those spaces\
            \ before the code! Indentation is important and code that is not indented\
            \ correctly will fail and require fixing before it can be run.\n\nRESPONSE\
            \ FORMAT:\nYour shell prompt is formatted as follows:\n(Open file: <path>)\
            \ <cwd> $\n\nYou need to format your output using one field: command.\n\
            Your output should always include *one* command field EXACTLY as in the\
            \ following example:\nFirst I'll start by using ls to see what files are\
            \ in the current directory. Then maybe we can look at some relevant files\
            \ to see what they look like.\n```\nls -a\n```\n\nYou should only include\
            \ a *SINGLE* command in the command section and then wait for a response\
            \ from the shell before continuing with more discussion and commands.\n\
            If you'd like to issue two commands at once, PLEASE DO NOT DO THAT! Please\
            \ instead first submit just the first command, and then after receiving\
            \ a response you'll be able to issue the second command.\nYou're free\
            \ to use any other bash commands you want (e.g. find, grep, cat, ls, cd)\
            \ in addition to the special commands listed above.\nHowever, the environment\
            \ does NOT support interactive session commands (e.g. python, vim), so\
            \ please do not invoke them.\n\nOnce you make *NO PROGRESS* on current\
            \ task, you should stop generating next action. Instead, if current task\
            \ is succeeded, you should output `succeed`. If failed, you should output\
            \ `fail`.\nRESPONSE FORMAT:\nYour output should always contains a SUMMARY\
            \ OF ALL ACTIONS PERFORMED and the TASK STATUS (`succeed` or `fail`).\
            \ \nDISCUSSION\nThrough the analysis of the issue and the search within\
            \ the project, the issue has been reproduced in the <path/to.py> file.\n\
            ```\nsucceed\n```\n\nIMPORTANT TIPS: your job is to verify the test `reproduce.py`\
            \ does not incur any errors."
          util_functions:
          - arguments: null
            code: '_print() {    local total_lines=$(awk ''END {print NR}'' $CURRENT_FILE)    echo
              "[File: $(realpath $CURRENT_FILE) ($total_lines lines total)]"    lines_above=$(jq
              -n "$CURRENT_LINE - $WINDOW/2" | jq ''[0, .] | max | floor'')    lines_below=$(jq
              -n "$total_lines - $CURRENT_LINE - $WINDOW/2" | jq ''[0, .] | max |
              round'')    if [ $lines_above -gt 0 ]; then        echo "($lines_above
              more lines above)"    fi    cat $CURRENT_FILE | grep -n $ | head -n
              $(jq -n "[$CURRENT_LINE + $WINDOW/2, $WINDOW/2] | max | floor") | tail
              -n $(jq -n "$WINDOW")    if [ $lines_below -gt 0 ]; then        echo
              "($lines_below more lines below)"    fi}'
            docstring: null
            end_name: null
            name: _print
            signature: _print
          - arguments: null
            code: _constrain_line() {    if [ -z "$CURRENT_FILE" ]    then        echo
              "No file open. Use the open command first."        return    fi    local
              max_line=$(awk 'END {print NR}' $CURRENT_FILE)    local half_window=$(jq
              -n "$WINDOW/2" | jq 'floor')    export CURRENT_LINE=$(jq -n "[$CURRENT_LINE,
              $max_line - $half_window] | min")    export CURRENT_LINE=$(jq -n "[$CURRENT_LINE,
              $half_window] | max")}
            docstring: null
            end_name: null
            name: _constrain_line
            signature: _constrain_line
        config_file: config/configs/roles/verifier.yaml
        model:
          host_url: localhost:11434
          model_name: azure:gpt-4o-2024-05-13
          per_instance_cost_limit: 0.0
          replay_path: null
          temperature: 1.0
          top_p: 1.0
          total_cost_limit: 0.0
      agent_file: config/configs/roles/verifier.yaml
      docstring: null
      end_name: null
      init_observation: null
      model:
        host_url: localhost:11434
        model_name: azure:gpt-4o-2024-05-13
        per_instance_cost_limit: 0.0
        replay_path: null
        temperature: 1.0
        top_p: 1.0
        total_cost_limit: 0.0
      name: Tester
      return_type: traj
      signature: null
    system_template: |-
      SETTING: You are a Manager responsible for overseeing a software engineering team. Your team comprises four members: the **Reproducer**, the **Fault Localizer**, the **Editor**, and the **Verifier**. Your primary task is to efficiently solve GitHub issues and ensure smooth collaboration among team members.

      you should analyze the given issue, and select a plan from predefined ones, that is, to organize a team, arrange team roles, and designate task processes.
      Besides, you're working directly in the command line with a special interface.
      The special interface consists of a file editor that shows you {WINDOW} lines of a file at a time.
      In addition to typical bash commands, you can also use the following commands to help you navigate and edit files.

      COMMANDS:
      {command_docs}

      RESPONSE FORMAT:
      Your shell prompt is formatted as follows:
      (Open file: <path>) <cwd> $

      You need to format your output using two fields; discussion and command.
      Your output should always include _one_ discussion and _one_ plan field EXACTLY as in the following example:
      DISCUSSION
      According the issue description and previous attempts, I'll try the following plan to solve this issue.

      COMMAND
      ```
      plan
      {{
        "entry": "Reproducer",
        "roles": [
          {{
            "name": "Reproducer",
            "attributes": {{
              "task": "If possible, try to extract test scripts from the issue description. Otherwise, generate test scripts based on the issue description yourself. Paste it into `path/to/reproduce.py`. Run `path/to/reproduce.py` and compare error messages with those in the description. If successfully reproduced, forward the error message to the Debugger. If not, forward \"cannot reproduce\" to the Programmer.",
              "constraint": "",
              "downstream": {{
                "succeed": {{
                  "to": "Debugger",
                  "info": "ErrMsg"
                }},
                "fail": {{
                  "to": "Programmer",
                  "info": "Plan Failed"
                }}
              }}
            }}
          }},
          {{
            "name": "Debugger",
            "attributes": {{
              "task": "You will now take the role of a tester and fault localizer, communicating with a Programmer (who will edit the code to fix the issue). First, run the reproduction script and relevant unit tests, by identify the tests that are relevant to the issue, identify the failing tests. Second, add any additional tests that are needed to ensure the issue is fixed robustly. DO NOT try to fix the code yourself. Instead, ask the Programmer to modify the code to fix the issue, and you will test the code again to check if the issue is fixed. In order to communicate with the Programmer, you MUST include end_turn as the action in your response.",
              "constraint": "",
              "downstream": {{
                "succeed": {{
                  "to": "Programmer",
                  "info": "FilesToModify,FunctionsToModify"
                }},
                "fail": {{
                  "to": "Programmer",
                  "info": "N/A"
                }}
              }}
            }}
          }},
          {{
            "name": "Programmer",
            "attributes": {{
              "task": "You will now take the role of a programmer, editing the code to fix the issue, communicating with a Tester (who will test the code to check if the issue is fixed).",
              "constraint": "",
              "downstream": {{
                "succeed": {{
                  "to": "Tester",
                  "info": "Patch"
                }},
                "fail": {{
                  "to": "Manager",
                  "info": "PlanFailed"
                }}
              }}
            }}
          }},
          {{
          "name": "Tester",
          "attributes": {{
            "task": "Test whether the issue has been fixed.",
            "constraint": "",
            "downstream": {{
              "succeed": {{
                "to": "Programmer",
                "info": "Patch"
              }},
              "fail": {{
                "to": "Manager",
                "info": "PlanFailed"
              }}
            }}
          }}
        }}
        ]
      }}
      end_of_plan
      ```

      Another example:
      DISCUSSION
      First I'll start by using ls to see what files are in the current directory. Then maybe we can look at some relevant files to see what they look like.

      COMMAND
      ```
      ls -a
      ```

      Note, the content of the plan needs to be wrapped with `plan` and `end_of_plan`, enclosed by ```.
      You should only include a *SINGLE* command in the command section and then wait for a response with more discussions. Everything you include in the DISCUSSION section will be saved for future reference.
      If you'd like to issue two plans or commands at once, PLEASE DO NOT DO THAT!

      IMPORTANT TIPS: your job is only to select a plan to resolve the issue and not to create a new plan yourself. DO NOT EDIT THE CODE IN THE REPOSITORY!!!
    util_functions:
    - arguments: null
      code: '_print() {    local total_lines=$(awk ''END {print NR}'' $CURRENT_FILE)    echo
        "[File: $(realpath $CURRENT_FILE) ($total_lines lines total)]"    lines_above=$(jq
        -n "$CURRENT_LINE - $WINDOW/2" | jq ''[0, .] | max | floor'')    lines_below=$(jq
        -n "$total_lines - $CURRENT_LINE - $WINDOW/2" | jq ''[0, .] | max | round'')    if
        [ $lines_above -gt 0 ]; then        echo "($lines_above more lines above)"    fi    cat
        $CURRENT_FILE | grep -n $ | head -n $(jq -n "[$CURRENT_LINE + $WINDOW/2, $WINDOW/2]
        | max | floor") | tail -n $(jq -n "$WINDOW")    if [ $lines_below -gt 0 ];
        then        echo "($lines_below more lines below)"    fi}'
      docstring: null
      end_name: null
      name: _print
      signature: _print
    - arguments: null
      code: _constrain_line() {    if [ -z "$CURRENT_FILE" ]    then        echo "No
        file open. Use the open command first."        return    fi    local max_line=$(awk
        'END {print NR}' $CURRENT_FILE)    local half_window=$(jq -n "$WINDOW/2" |
        jq 'floor')    export CURRENT_LINE=$(jq -n "[$CURRENT_LINE, $max_line - $half_window]
        | min")    export CURRENT_LINE=$(jq -n "[$CURRENT_LINE, $half_window] | max")}
      docstring: null
      end_name: null
      name: _constrain_line
      signature: _constrain_line
  config_file: config/configs/roles/chat_manager_v2.yaml
  model:
    host_url: localhost:11434
    model_name: azure:gpt-4o-2024-05-13
    per_instance_cost_limit: 3.0
    replay_path: null
    temperature: 0.0
    top_p: 1.0
    total_cost_limit: 0.0
environment:
  base_commit: null
  cache_task_images: false
  container_name: null
  data_path: problem_statement1.md
  environment_setup: null
  image_name: sweagent/swe-agent:latest
  install_environment: false
  no_mirror: false
  repo_path: /home/minkim/Snowflake/trunk
  split: dev
  timeout: null
  verbose: true
instance_filter: .*
print_config: true
raise_exceptions: false
skip_existing: true
suffix: exp8
